for (i in 1:adf_test){
diff_serie = diff(diff_serie)
}
results[[col_name]] = diff_serie
} else {
results[[col_name]] = serie
}
}
return(list(results = results, ndiffs = suport_df))
}
source("~/GitHub/gdp-forecasting-with-ML/07_call_Model.R", echo=TRUE)
df_st <- get_stationary_SW(df, sw_test)
View(df_st)
df_info_st <- df_st$info
df_st <- do.call(cbind, df_st$results) %>% as.data.frame()
warnings()
View(df)
# Lasso model
lasso_model <- call_models(df, 'Lasso', get_lasso, "y")
# Lasso model
lasso_model <- call_models(df, 'Lasso', get_lasso, "y")
source("~/GitHub/gdp-forecasting-with-ML/07_call_Model.R", echo=TRUE)
# Lasso model
lasso_model <- call_models(df, 'Lasso', get_lasso, "y")
source("~/GitHub/gdp-forecasting-with-ML/test_df.R", echo=TRUE)
ts.plot(df$y)
is_stattest <- get_stationarity(df)
View(is_stattest)
is_stattest[["ndiffs"]][["ndiffs"]]
df_st <- get_stationary_SW(df, sw_test)
warnings()
source("~/GitHub/gdp-forecasting-with-ML/test_df.R", echo=TRUE)
is_stattest <- get_stationarity(df)
View(is_stattest)
is_stattest[["ndiffs"]][["ndiffs"]]
message("Mean")
# Mean model
mean_model <- call_models(df, 'Mean', get_mean, "y")
message("SARIMA")
# Benchmark (SARIMA)
benchmark <- call_models(df, 'Sarima', get_sarima, "y")
message("LASSO")
# Lasso model
lasso_model <- call_models(df, 'Lasso', get_lasso, "y")
dataprep <- function(type = '...', ind, df, variable, horizon, n_lags = 4) {
#' Preparação de Dados para Modelagem
#'
#' Esta função prepara os dados para análise, criando variáveis de defasagem e separando as variáveis dependentes e independentes.
#'
#' @param type Um caractere que define o tipo de preparação de dados. Pode ser 'tb' para uma estrutura de tabela ou outro valor conforme necessário.
#' @param ind Um vetor de índices para selecionar as linhas do `data.frame`.
#' @param df Um `data.frame` contendo os dados a serem preparados.
#' @param variable O nome da variável dependente a ser utilizada na análise.
#' @param horizon O horizonte de previsão, que determina quantas observações devem ser projetadas para frente.
#' @param n_lags O número de defasagens a serem criadas. Deve ser um inteiro maior que 1. O padrão é 4.
#' @return Uma lista com três elementos:
#' - x_in: Um `data.frame` contendo as variáveis independentes de entrada, excluindo os últimos `horizon` registros.
#' - x_out: Um vetor contendo a última observação das variáveis independentes (a previsão).
#' - y_in: Um vetor com os valores correspondentes da variável dependente para as observações de entrada.
#'
#' @examples
#' df <- data.frame(data = 1:100, variable = rnorm(100))
#' result <- dataprep(type = 'tb', ind = 1:80, df = df, variable = 'variable', horizon = 1, n_lags = 4)
#'
#' @export
if (n_lags <= 1) {
stop("n_lags deve ser um inteiro maior do que 1.")
}
df <- df[ind, ]
y <- df[, variable]
if (type == 'tb'){
x_aux = df[,-1]
} else{
x_aux = df
}
x <- embed(as.matrix(x_aux), n_lags)
names_x <- NULL
for (i in seq_len(n_lags)) {
names_x <- c(
names_x,
paste(colnames(x_aux), "_lag_", horizon + i - 1, sep = "")
)
}
colnames(x) <- names_x
x_in <- x[-c((nrow(x) - horizon + 1):nrow(x)), ]
x_out <- x[nrow(x), ]
x_out <- t(as.vector(x_out))
y_in <- tail(y, nrow(x_in))
return(list(x_in = x_in, x_out = x_out, y_in = y_in))
}
rolling_window <- function(fn, df, nwindow = 1, horizon, variable, ...) {
#' Janela Movel para Modelagem
#'
#' Esta função aplica uma função especificada a uma janela deslizante de dados em um `data.frame` para realizar previsões.
#'
#' @param fn A função a ser aplicada em cada janela deslizante. Esta função deve retornar um objeto com as previsões e saídas.
#' @param df Um `data.frame` contendo os dados a serem processados.
#' @param nwindow O tamanho da janela deslizante. O padrão é 1.
#' @param horizon O horizonte de previsão, que determina quantas observações devem ser projetadas para frente.
#' @param variable O nome da variável dependente a ser utilizada na análise.
#' @param ... Argumentos adicionais a serem passados para a função `fn`.
#' @return Uma lista com dois elementos:
#' - forecast: Um vetor com as previsões resultantes de cada aplicação da função nas janelas deslizantes.
#' - outputs: Uma lista contendo as saídas resultantes de cada aplicação da função nas janelas deslizantes.
#'
#' @examples
#' df <- data.frame(data = 1:100, variable = rnorm(100))
#' result <- rolling_window(fn = my_forecast_function, df = df, nwindow = 5, horizon = 1, variable = 'variable')
#'
#' @export
#ind <- seq_len(nrow(df))
window_size <- nrow(df) - nwindow
indmat <- matrix(NA, window_size, nwindow)
indmat[1, ] <- seq_len(ncol(indmat))
for (i in 2:nrow(indmat)) {
indmat[i, ] <- indmat[i - 1, ] + 1
}
rw <- apply(
X = indmat,
MARGIN = 2,
FUN = fn,
df = df,
horizon = horizon,
variable = variable,
...
)
forecast <- unlist(lapply(rw, function(x) x$forecast))
outputs <- lapply(rw, function(x) x$outputs)
return(list(forecast = forecast, outputs = outputs))
}
get_boosting <- function(ind, df, variable, horizon, n_lags) {
#' Ajuste de Modelo de Boosting
#'
#' Esta função ajusta um modelo de boosting aos dados fornecidos e gera previsões.
#'
#' @param ind Índices das observações a serem utilizadas.
#' @param df Um data.frame contendo os dados.
#' @param variable Nome da variável dependente a ser modelada.
#' @param horizon Horizonte de previsão.
#' @param n_lags Número de defasagens a serem usadas na modelagem.
#' @return Uma lista contendo as previsões do modelo de boosting e informações sobre o modelo ajustado.
#'
#' @examples
#' results <- get_boosting(ind = 1:100, df = my_data, variable = "sales", horizon = 10, n_lags = 4)
library(mboost)
library(forecast)
# INICIALIZACAO DE VARIAVEIS
set.seed(100)
data_in <- dataprep(
type = 'default',
#type = 'tb',
ind = ind,
df = df,
variable = variable,
horizon = horizon,
n_lags = n_lags
)
y_in <- data_in$y_in
x_in <- data_in$x_in
x_out <- data_in$x_out
# AJUSTE DO MODELO DE BOOSTING
reg_full <- glmboost(
y = y_in,
x = as.matrix(x_in),
offset = 0, # mean(y_in),
center = TRUE,
control = boost_control(mstop = 300, nu = 0.1)
)
# DETERMINACAO DO NUMERO OTIMO DE ITERACOES
cv5f <- cv(model.weights(reg_full), type = "kfold", B = 5)
cv_seq <- cvrisk(reg_full, folds = cv5f, papply = lapply)
m_opt <- mstop(cv_seq)
# AJUSTE DO MODELO COM O NUMERO OTIMO DE ITERACOES
reg_opt <- reg_full[m_opt]
# PREVISAO PARA A JANELA DE TESTE
opt_boosting <- predict(
object = reg_opt,
newdata = matrix(x_out, nrow = 1)
) %>% as.vector() + mean(y_in)
# RESULTADOS
results <- list(
forecast = opt_boosting,
outputs = list(
m_opt = m_opt,
reg_opt = reg_opt
)
)
return(results)
}
source("~/GitHub/gdp-forecasting-with-ML/06_get_Models.R", echo=TRUE)
source("~/GitHub/gdp-forecasting-with-ML/07_call_Model.R", echo=TRUE)
source("~/GitHub/gdp-forecasting-with-ML/05_get_Rolling_Window.R", echo=TRUE)
source("~/GitHub/gdp-forecasting-with-ML/04_get_Data_Prep.R", echo=TRUE)
source("~/GitHub/gdp-forecasting-with-ML/01_get_Data.R", echo=TRUE)
# Mean model
mean_model <- call_models(df, 'Mean', get_mean, "y")
# Benchmark (SARIMA)
benchmark <- call_models(df, 'Sarima', get_sarima, "y")
# Mean model
mean_model <- call_models(df, 'Mean', get_mean, "y")
dataprep_test <- dataprep(type = 'tb', ind = 1:80, df = df, variable = 'y', horizon = 1, n_lags = 4)
dataprep <- function(type = '...', ind, df, variable, horizon, n_lags = 4) {
#' Preparação de Dados para Modelagem
#'
#' Esta função prepara os dados para análise, criando variáveis de defasagem e separando as variáveis dependentes e independentes.
#'
#' @param type Um caractere que define o tipo de preparação de dados. Pode ser 'tb' para uma estrutura de tabela ou outro valor conforme necessário.
#' @param ind Um vetor de índices para selecionar as linhas do `data.frame`.
#' @param df Um `data.frame` contendo os dados a serem preparados.
#' @param variable O nome da variável dependente a ser utilizada na análise.
#' @param horizon O horizonte de previsão, que determina quantas observações devem ser projetadas para frente.
#' @param n_lags O número de defasagens a serem criadas. Deve ser um inteiro maior que 1. O padrão é 4.
#' @return Uma lista com três elementos:
#' - x_in: Um `data.frame` contendo as variáveis independentes de entrada, excluindo os últimos `horizon` registros.
#' - x_out: Um vetor contendo a última observação das variáveis independentes (a previsão).
#' - y_in: Um vetor com os valores correspondentes da variável dependente para as observações de entrada.
#'
#' @examples
#' df <- data.frame(data = 1:100, variable = rnorm(100))
#' result <- dataprep(type = 'tb', ind = 1:80, df = df, variable = 'variable', horizon = 1, n_lags = 4)
#'
#' @export
if (n_lags <= 1) {
stop("n_lags deve ser um inteiro maior do que 1.")
}
df <- df[ind, ]
y <- df[, variable]
if (type == 'tb'){
x_aux = df[,-1]
} else{
x_aux = df
}
x <- embed(as.matrix(x_aux), n_lags)
names_x <- NULL
for (i in seq_len(n_lags)) {
names_x <- c(
names_x,
paste(colnames(x_aux), "_lag_", horizon + i - 1, sep = "")
)
}
colnames(x) <- names_x
x_in <- x[-c((nrow(x) - horizon + 1):nrow(x)), ]
x_out <- x[nrow(x), ]
x_out <- t(as.vector(x_out))
y_in <- tail(y, nrow(x_in))
return(list(x_in = x_in, x_out = x_out, y_in = y_in))
}
dataprep_test <- dataprep(type = 'tb', ind = 1:80, df = df, variable = 'y', horizon = 1, n_lags = 4)
View(dataprep_test)
dataprep_test[["x_in"]]
dataprep_test[["y_in"]]
dataprep_test[["x_out"]]
x_in <- as.data.frame(dataprep_test[["x_in"]])
dataprep_test <- dataprep(type = 'tb', ind = 1:80, df = df, variable = 'y', horizon = 1, n_lags = 4)
x_in <- as.data.frame(dataprep_test[["x_in"]])
x_out <- as.data.frame(dataprep_test[["x_out"]])
y_in <- as.data.frame(dataprep_test[["y_in"]])
View(x_in)
dataprep_test <- dataprep(type = 'tb', ind = 1:80, df = df, variable = 'y', horizon = 1, n_lags = 8)
x_in <- as.data.frame(dataprep_test[["x_in"]])
dataprep_test <- dataprep(type = 'tb', ind = 1:80, df = df, variable = 'y', horizon = 4, n_lags = 4)
x_in <- as.data.frame(dataprep_test[["x_in"]])
x <- embed(as.matrix(df), 4)
View(x)
View(x)
dataprep_test <- dataprep(type = 'tb', ind = 1:80, df = df, variable = 'y', horizon = 4, n_lags = 2)
x_in <- as.data.frame(dataprep_test[["x_in"]])
View(x_in)
source("~/GitHub/gdp-forecasting-with-ML/05_get_Rolling_Window.R", echo=TRUE)
source("~/GitHub/gdp-forecasting-with-ML/06_get_Models.R", echo=TRUE)
source("~/GitHub/gdp-forecasting-with-ML/07_call_Model.R", echo=TRUE)
# Mean model
mean_model <- call_models(df, 'Mean', get_mean, "y")
get_mean = function(ind, df, variable, horizon, n_lags, verbose = TRUE){
data_in = dataprep(
type = 'tb',
ind = ind,
df = df,
variable = variable,
horizon = horizon,
n_lags = n_lags
)
y_in = as.numeric(data_in$y_in)
mu = mean(y_in)
results = list(
forecast = rep(mu, horizon),
outputs = list(mean = mu)
)
return(results)
}
# Mean model
mean_model <- call_models(df, 'Mean', get_mean, "y")
# Mean model
mean_model <- call_models(df, 'Mean', get_mean, "y")
get_mean = function(ind, df, variable, horizon, n_lags, verbose = TRUE){
data_in = dataprep(
type = 'tb',
ind = ind,
df = df,
variable = variable,
horizon = horizon,
n_lags = n_lags
)
y_in = as.numeric(data_in$y_in)
mu = mean(y_in)
results = list(
forecast = rep(mu, horizon),
outputs = list(mean = mu)
)
return(results)
}
# Mean model
mean_model <- call_models(df, 'Mean', get_mean, "y")
call_models = function(data, model_name, model_function, variable, type = "tb"){
#' Chamadas para Modelos de Previsão
#'
#' Esta função aplica um modelo de previsão a um conjunto de dados, utilizando uma janela deslizante para gerar previsões.
#'
#' @param data Um `data.frame` ou matriz contendo os dados a serem modelados.
#' @param model_name O nome do modelo a ser utilizado (apenas um rótulo).
#' @param model_function A função que implementa o modelo de previsão a ser aplicado.
#' @param variable O nome da variável dependente que será prevista.
#' @param type O tipo de dados. O padrão é "default".
#' @return Uma lista contendo os seguintes elementos:
#' - me: O erro médio das previsões.
#' - rmse: A raiz do erro quadrático médio das previsões.
#' - forecasts: As previsões geradas pelo modelo para o horizonte definido.
#'
#' @examples
#' df <- data.frame(time = 1:100, variable = rnorm(100))
#' results <- call_models(data = df, model_name = "MyModel", model_function = my_model_function, variable = "variable")
#'
#' @export
data = as.matrix(data)
model_name <- model_name
model_function <- model_function
nwindows = nrow(data)*0.25
y_out <- tail(data[, variable], nwindows)
#y_out <- tail(data[, "BZEAMOM"], nwindows)
#if (type == 'tb'){
#  data <- as.data.frame(data) %>%
#    select(-c(1)) %>%
#    as.matrix()
#}
model_list <- list()
for_ind <- c(1, 4)
#for_ind = c(1)
for (i in for_ind) {
model <- rolling_window(
fn = model_function,
df = data,
nwindow = nwindows + i - 1,
horizon = i,
variable = variable,
n_lags = 4
)
model_list[[i]] <- model
cat(i, "\n")
}
forecasts <- Reduce(
f = cbind,
x = lapply(model_list, function(x) head(x$forecast, nwindows))
) %>% as.matrix()
plot.ts(y_out)
lines(forecasts[, 1], col = 2)
rmse <- apply(forecasts, 2, f_rmse, y = y_out) %>% print()
me = apply(forecasts, 2, f_me, y = y_out) %>% print()
results = list(me = me, rmse = rmse, forecasts = forecasts)
return(results)
}
# Mean model
mean_model <- call_models(df, 'Mean', get_mean, "y")
get_mean = function(ind, df, variable, horizon, n_lags){
data_in = dataprep(
type = 'tb',
ind = ind,
df = df,
variable = variable,
horizon = horizon,
n_lags = n_lags
)
y_in = as.numeric(data_in$y_in)
mu = mean(y_in)
results = list(
forecast = rep(mu, horizon),
outputs = list(mean = mu)
)
return(results)
}
# Mean model
mean_model <- call_models(df, 'Mean', get_mean, "y")
call_models = function(data, model_name, model_function, variable, type = "tb"){
#' Chamadas para Modelos de Previsão
#'
#' Esta função aplica um modelo de previsão a um conjunto de dados, utilizando uma janela deslizante para gerar previsões.
#'
#' @param data Um `data.frame` ou matriz contendo os dados a serem modelados.
#' @param model_name O nome do modelo a ser utilizado (apenas um rótulo).
#' @param model_function A função que implementa o modelo de previsão a ser aplicado.
#' @param variable O nome da variável dependente que será prevista.
#' @param type O tipo de dados. O padrão é "default".
#' @return Uma lista contendo os seguintes elementos:
#' - mae: O erro absoluto médio das previsões.
#' - rmse: A raiz do erro quadrático médio das previsões.
#' - forecasts: As previsões geradas pelo modelo para o horizonte definido.
#'
#' @examples
#' df <- data.frame(time = 1:100, variable = rnorm(100))
#' results <- call_models(data = df, model_name = "MyModel", model_function = my_model_function, variable = "variable")
#'
#' @export
data = as.matrix(data)
model_name <- model_name
model_function <- model_function
nwindows = nrow(data)*0.25
y_out <- tail(data[, variable], nwindows)
#if (type == 'tb'){
#  data <- as.data.frame(data) %>%
#    select(-c(1)) %>%
#    as.matrix()
#}
model_list <- list()
for_ind <- c(1, 4)
for (i in for_ind) {
model <- rolling_window(
fn = model_function,
df = data,
nwindow = nwindows + i - 1,
horizon = i,
variable = variable,
n_lags = 4
)
model_list[[i]] <- model
cat(i, "\n")
}
forecasts <- Reduce(
f = cbind,
x = lapply(model_list, function(x) head(x$forecast, nwindows))
) %>% as.matrix()
plot.ts(y_out)
lines(forecasts[, 1], col = 2)
rmse <- apply(forecasts, 2, f_rmse, y = y_out) %>% print()
mae = apply(forecasts, 2, f_mae, y = y_out) %>% print()
results = list(mae = mae, rmse = rmse, forecasts = forecasts)
return(results)
}
# Mean model
mean_model <- call_models(df, 'Mean', get_mean, "y")
# Benchmark (SARIMA)
benchmark <- call_models(df, 'Sarima', get_sarima, "y")
traceback()
# Mean model
mean_model <- call_models(df, 'Mean', get_mean, "y")
traceback()
call_models = function(data, model_name, model_function, variable, type = "tb"){
#' Chamadas para Modelos de Previsão
#'
#' Esta função aplica um modelo de previsão a um conjunto de dados, utilizando uma janela deslizante para gerar previsões.
#'
#' @param data Um `data.frame` ou matriz contendo os dados a serem modelados.
#' @param model_name O nome do modelo a ser utilizado (apenas um rótulo).
#' @param model_function A função que implementa o modelo de previsão a ser aplicado.
#' @param variable O nome da variável dependente que será prevista.
#' @param type O tipo de dados. O padrão é "default".
#' @return Uma lista contendo os seguintes elementos:
#' - mae: O erro absoluto médio das previsões.
#' - rmse: A raiz do erro quadrático médio das previsões.
#' - forecasts: As previsões geradas pelo modelo para o horizonte definido.
#'
#' @examples
#' df <- data.frame(time = 1:100, variable = rnorm(100))
#' results <- call_models(data = df, model_name = "MyModel", model_function = my_model_function, variable = "variable")
#'
#' @export
data = as.matrix(data)
model_name <- model_name
model_function <- model_function
nwindows = nrow(data)*0.25
y_out <- tail(data[, variable], nwindows)
#if (type == 'tb'){
#  data <- as.data.frame(data) %>%
#    select(-c(1)) %>%
#    as.matrix()
#}
model_list <- list()
for_ind <- c(1, 4)
for (i in for_ind) {
model <- rolling_window(
fn = model_function,
df = data,
nwindow = nwindows + i - 1,
horizon = i,
variable = variable,
n_lags = 4
)
model_list[[i]] <- model
cat(i, "\n")
}
forecasts <- Reduce(
f = cbind,
x = lapply(model_list, function(x) head(x$forecast, nwindows))
) %>% as.matrix()
print(forecasts)
plot.ts(y_out)
lines(forecasts[, 1], col = 2)
rmse <- apply(forecasts, 2, f_rmse, y = y_out) %>% print()
mae = apply(forecasts, 2, f_mae, y = y_out) %>% print()
results = list(mae = mae, rmse = rmse, forecasts = forecasts)
return(results)
}
# Mean model
mean_model <- call_models(df, 'Mean', get_mean, "y")
