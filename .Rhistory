stepwise = F,
approximation = F,
stationary = F,
seasonal = T,
start.p = 0,
start.q = 0)
print(reg_arima)
for_arima_aux = forecast(
object = reg_arima,
h = horizon)
forecasts = for_arima_aux$mean
results = list(forecasts = forecasts)
return (results)
}
#BENCHMARK
benchmark = call_models(dataset, 'Sarima', get_sarima, "pib_rs")
get_sarima = function(ind, df, variable, horizon, n_lags = 4){
#' Ajuste de Modelo SARIMA
#'
#' Esta função ajusta um modelo SARIMA aos dados fornecidos e gera previsões.
#'
#' @param ind Índices das observações a serem utilizadas.
#' @param df Um data.frame contendo os dados.
#' @param variable Nome da variável dependente a ser modelada.
#' @param horizon Horizonte de previsão.
#' @param n_lags Número de defasagens a serem usadas na modelagem.
#' @return Uma lista contendo as previsões do modelo SARIMA.
#'
#' @examples
#' results <- get_sarima(ind = 1:100, df = my_data, variable = "sales", horizon = 10, n_lags = 4)
library(tidyverse)
library(forecast)
data_in = dataprep(
ind = ind,
df = df,
variable = variable,
horizon = horizon,
n_lags = n_lags)
#INICIANDO AS VARIAVEIS
y_in = data_in$y_in
print(length(y_in))
sd(y_in)
reg_arima = auto.arima(
y = y_in,
stepwise = F,
approximation = F,
stationary = F,
seasonal = T,
start.p = 0,
start.q = 0)
print(reg_arima)
for_arima_aux = forecast(
object = reg_arima,
h = horizon)
forecasts = for_arima_aux$mean
results = list(forecasts = forecasts)
return (results)
}
#BENCHMARK
benchmark = call_models(dataset, 'Sarima', get_sarima, "pib_rs")
sd(dataset$pib_rs)
dataprep <- function(type = 'tb', ind, df, variable, horizon, n_lags = 4) {
#' Preparação de Dados para Modelagem
#'
#' Esta função prepara os dados para análise, criando variáveis de defasagem e separando as variáveis dependentes e independentes.
#'
#' @param type Um caractere que define o tipo de preparação de dados. Pode ser 'tb' para uma estrutura de tabela ou outro valor conforme necessário.
#' @param ind Um vetor de índices para selecionar as linhas do `data.frame`.
#' @param df Um `data.frame` contendo os dados a serem preparados.
#' @param variable O nome da variável dependente a ser utilizada na análise.
#' @param horizon O horizonte de previsão, que determina quantas observações devem ser projetadas para frente.
#' @param n_lags O número de defasagens a serem criadas. Deve ser um inteiro maior que 1. O padrão é 4.
#' @return Uma lista com três elementos:
#' - x_in: Um `data.frame` contendo as variáveis independentes de entrada, excluindo os últimos `horizon` registros.
#' - x_out: Um vetor contendo a última observação das variáveis independentes (a previsão).
#' - y_in: Um vetor com os valores correspondentes da variável dependente para as observações de entrada.
#'
#' @examples
#' df <- data.frame(data = 1:100, variable = rnorm(100))
#' result <- dataprep(type = 'tb', ind = 1:80, df = df, variable = 'variable', horizon = 1, n_lags = 4)
#'
#' @export
if (n_lags <= 1) {
stop("n_lags must be an integer greater than 1.")
}
df <- df[ind, ]
y <- df[, variable]
if (type == 'tb'){
x_aux = df[,-1]
} else{
x_aux = df
}
x <- embed(as.matrix(x_aux), n_lags)
names_x <- NULL
for (i in seq_len(n_lags)) {
names_x <- c(
names_x,
paste(colnames(x_aux), "_lag_", horizon + i - 1, sep = "")
)
}
colnames(x) <- names_x
x_in <- x[-c((nrow(x) - horizon + 1):nrow(x)), ]
x_out <- x[nrow(x), ]
x_out <- t(as.vector(x_out))
y_in <- tail(y, nrow(x_in))
return(list(x_in = x_in, x_out = x_out, y_in = y_in))
}
#BENCHMARK
benchmark = call_models(dataset, 'Sarima', get_sarima, "pib_rs")
dataprep <- function(type = '...', ind, df, variable, horizon, n_lags = 4) {
#' Preparação de Dados para Modelagem
#'
#' Esta função prepara os dados para análise, criando variáveis de defasagem e separando as variáveis dependentes e independentes.
#'
#' @param type Um caractere que define o tipo de preparação de dados. Pode ser 'tb' para uma estrutura de tabela ou outro valor conforme necessário.
#' @param ind Um vetor de índices para selecionar as linhas do `data.frame`.
#' @param df Um `data.frame` contendo os dados a serem preparados.
#' @param variable O nome da variável dependente a ser utilizada na análise.
#' @param horizon O horizonte de previsão, que determina quantas observações devem ser projetadas para frente.
#' @param n_lags O número de defasagens a serem criadas. Deve ser um inteiro maior que 1. O padrão é 4.
#' @return Uma lista com três elementos:
#' - x_in: Um `data.frame` contendo as variáveis independentes de entrada, excluindo os últimos `horizon` registros.
#' - x_out: Um vetor contendo a última observação das variáveis independentes (a previsão).
#' - y_in: Um vetor com os valores correspondentes da variável dependente para as observações de entrada.
#'
#' @examples
#' df <- data.frame(data = 1:100, variable = rnorm(100))
#' result <- dataprep(type = 'tb', ind = 1:80, df = df, variable = 'variable', horizon = 1, n_lags = 4)
#'
#' @export
if (n_lags <= 1) {
stop("n_lags must be an integer greater than 1.")
}
df <- df[ind, ]
y <- df[, variable]
if (type == 'tb'){
x_aux = df[,-1]
} else{
x_aux = df
}
x <- embed(as.matrix(x_aux), n_lags)
names_x <- NULL
for (i in seq_len(n_lags)) {
names_x <- c(
names_x,
paste(colnames(x_aux), "_lag_", horizon + i - 1, sep = "")
)
}
colnames(x) <- names_x
x_in <- x[-c((nrow(x) - horizon + 1):nrow(x)), ]
x_out <- x[nrow(x), ]
x_out <- t(as.vector(x_out))
y_in <- tail(y, nrow(x_in))
return(list(x_in = x_in, x_out = x_out, y_in = y_in))
}
# date column is not the problem
str(dataset)
get_sarima = function(ind, df, variable, horizon, n_lags = 4){
#' Ajuste de Modelo SARIMA
#'
#' Esta função ajusta um modelo SARIMA aos dados fornecidos e gera previsões.
#'
#' @param ind Índices das observações a serem utilizadas.
#' @param df Um data.frame contendo os dados.
#' @param variable Nome da variável dependente a ser modelada.
#' @param horizon Horizonte de previsão.
#' @param n_lags Número de defasagens a serem usadas na modelagem.
#' @return Uma lista contendo as previsões do modelo SARIMA.
#'
#' @examples
#' results <- get_sarima(ind = 1:100, df = my_data, variable = "sales", horizon = 10, n_lags = 4)
library(tidyverse)
library(forecast)
data_in = dataprep(
ind = ind,
df = df,
variable = variable,
horizon = horizon,
n_lags = n_lags)
#INICIANDO AS VARIAVEIS
y_in = data_in$y_in
print(length(y_in))
sd(y_in)
reg_arima = auto.arima(
y = y_in,
stepwise = F,
approximation = F,
stationary = T,
seasonal = T,
start.p = 0,
start.q = 0)
print(reg_arima)
for_arima_aux = forecast(
object = reg_arima,
h = horizon)
forecasts = for_arima_aux$mean
results = list(forecasts = forecasts)
return (results)
}
#BENCHMARK
benchmark = call_models(dataset, 'Sarima', get_sarima, "pib_rs")
get_sarima = function(ind, df, variable, horizon, n_lags = 4){
#' Ajuste de Modelo SARIMA
#'
#' Esta função ajusta um modelo SARIMA aos dados fornecidos e gera previsões.
#'
#' @param ind Índices das observações a serem utilizadas.
#' @param df Um data.frame contendo os dados.
#' @param variable Nome da variável dependente a ser modelada.
#' @param horizon Horizonte de previsão.
#' @param n_lags Número de defasagens a serem usadas na modelagem.
#' @return Uma lista contendo as previsões do modelo SARIMA.
#'
#' @examples
#' results <- get_sarima(ind = 1:100, df = my_data, variable = "sales", horizon = 10, n_lags = 4)
library(tidyverse)
library(forecast)
data_in = dataprep(
ind = ind,
df = df,
variable = variable,
horizon = horizon,
n_lags = n_lags)
#INICIANDO AS VARIAVEIS
y_in = data_in$y_in
print(length(y_in))
sd(y_in)
reg_arima = auto.arima(
y = y_in,
stepwise = T,
approximation = F,
stationary = F,
seasonal = T,
start.p = 0,
start.q = 0)
print(reg_arima)
for_arima_aux = forecast(
object = reg_arima,
h = horizon)
forecasts = for_arima_aux$mean
results = list(forecasts = forecasts)
return (results)
}
#BENCHMARK
benchmark = call_models(dataset, 'Sarima', get_sarima, "pib_rs")
get_sarima = function(ind, df, variable, horizon, n_lags = 4){
#' Ajuste de Modelo SARIMA
#'
#' Esta função ajusta um modelo SARIMA aos dados fornecidos e gera previsões.
#'
#' @param ind Índices das observações a serem utilizadas.
#' @param df Um data.frame contendo os dados.
#' @param variable Nome da variável dependente a ser modelada.
#' @param horizon Horizonte de previsão.
#' @param n_lags Número de defasagens a serem usadas na modelagem.
#' @return Uma lista contendo as previsões do modelo SARIMA.
#'
#' @examples
#' results <- get_sarima(ind = 1:100, df = my_data, variable = "sales", horizon = 10, n_lags = 4)
library(tidyverse)
library(forecast)
data_in = dataprep(
ind = ind,
df = df,
variable = variable,
horizon = horizon,
n_lags = n_lags)
#INICIANDO AS VARIAVEIS
y_in = data_in$y_in
print(length(y_in))
sd(y_in)
reg_arima = auto.arima(
y = y_in,
stepwise = F,
approximation = F,
stationary = F,
seasonal = T,
start.p = 0,
start.q = 0)
print(reg_arima)
for_arima_aux = forecast(
object = reg_arima,
h = horizon)
forecasts = for_arima_aux$mean
results = list(forecasts = forecasts)
return (results)
}
get_sarima = function(ind, df, variable, horizon, n_lags){
#' Ajuste de Modelo SARIMA
#'
#' Esta função ajusta um modelo SARIMA aos dados fornecidos e gera previsões.
#'
#' @param ind Índices das observações a serem utilizadas.
#' @param df Um data.frame contendo os dados.
#' @param variable Nome da variável dependente a ser modelada.
#' @param horizon Horizonte de previsão.
#' @param n_lags Número de defasagens a serem usadas na modelagem.
#' @return Uma lista contendo as previsões do modelo SARIMA.
#'
#' @examples
#' results <- get_sarima(ind = 1:100, df = my_data, variable = "sales", horizon = 10, n_lags = 4)
library(tidyverse)
library(forecast)
data_in = dataprep(
ind = ind,
df = df,
variable = variable,
horizon = horizon,
n_lags = n_lags)
#INICIANDO AS VARIAVEIS
y_in = data_in$y_in
print(length(y_in))
sd(y_in)
reg_arima = auto.arima(
y = y_in,
stepwise = F,
approximation = F,
stationary = F,
seasonal = T,
start.p = 0,
start.q = 0)
print(reg_arima)
for_arima_aux = forecast(
object = reg_arima,
h = horizon)
forecasts = for_arima_aux$mean
results = list(forecasts = forecasts)
return (results)
}
#BENCHMARK
benchmark = call_models(df, 'Sarima', get_sarima, "pib_rs")
#BENCHMARK
benchmark = call_models(df, 'Sarima', get_sarima, "variable")
#BENCHMARK
benchmark = call_models(data_q, 'Sarima', get_sarima, "pib_rs")
get_lasso = function(ind, df, variable, horizon, n_lags){
#' Ajuste de Modelo Lasso
#'
#' Esta função ajusta um modelo de regressão Lasso aos dados fornecidos e gera previsões.
#'
#' @param ind Índices das observações a serem utilizadas.
#' @param df Um data.frame contendo os dados.
#' @param variable Nome da variável dependente a ser modelada.
#' @param horizon Horizonte de previsão.
#' @param n_lags Número de defasagens a serem usadas na modelagem.
#' @return Uma lista contendo as previsões do modelo Lasso.
#'
#' @examples
#' results <- get_lasso(ind = 1:100, df = my_data, variable = "sales", horizon = 10, n_lags = 4)
set.seed(100)
library(glmnet)
library(forecast)
#PREPARANDO OS DADOS
data_in = dataprep(
type = 'default',
#type = 'tb',
ind = ind,
df = df,
variable = variable,
horizon = horizon,
n_lags = 4)
#INICIANDO AS VARIAVEIS
y_in = data_in$y_in
x_in = data_in$x_in
x_out = data_in$x_out
#ESTIMANDO O MODELO
cv_lasso = cv.glmnet(
x = as.matrix(x_in),
y = y_in,
alpha = 1,
intercept = T,
standardize = T,
nfolds = 5)
grid <- 10^seq(10, -2, length = 100)
out = glmnet(x_in, y_in, alpha = 1, lambda = grid)
lasso.coef = predict(
out,
type = "coefficients",
s = cv_lasso$lambda.min)[1:41,]
print(lasso.coef[lasso.coef != 0])
#PREVISAO
opt_lasso = predict(
cv_lasso,
s = cv_lasso$lambda.min,
newx = as.matrix(x_out, nrow = 1))
results = list(forecast = opt_lasso)
return(results)
}
saveRDS(dataset, "qdataset.rds")
# with oob
get_rforest <- function(ind, df, variable, horizon, n_lags, verbose = TRUE) {
library(randomForest)
library(forecast)
# Data preparation
data_in <- dataprep(
type = "default",
ind = ind,
df = df,
variable = variable,
horizon = horizon,
n_lags = n_lags
)
y_in <- as.numeric(data_in$y_in)
x_in <- as.data.frame(data_in$x_in)
x_out <- as.data.frame(data_in$x_out)
x_out <- x_out[, colnames(x_in), drop = FALSE]
# Tune mtry using OOB error
p <- ncol(x_in)
mtry_grid <- unique(pmax(1, c(1L, floor(sqrt(p)), floor(p/3), floor(p/2), p)))
rf_list <- lapply(mtry_grid, function(m) {
model <- randomForest(
x = x_in,
y = y_in,
mtry = m,
ntree = 500,
nodesize = 5
)
list(model = model, oob_error = model$mse[500])
})
# Pick the best model
best <- rf_list[[which.min(sapply(rf_list, function(x) x$oob_error))]]
rf_opt <- best$model
# Forecast
rf_forecast <- predict(rf_opt, newdata = x_out)
return(list(
forecast = rf_forecast,
outputs = list(
rf_opt = rf_opt,
best_mtry = rf_opt$mtry
)
))
}
#with k-fold cross-validation (caret)
get_rf <- function(ind, df, variable, horizon, n_lags, verbose = TRUE) {
#' Ajuste de Modelo de Random Forest
#'
#' Esta função ajusta um modelo de Random Forest aos dados fornecidos e gera previsões.
#'
#' @param ind Índices das observações a serem utilizadas.
#' @param df Um data.frame contendo os dados.
#' @param variable Nome da variável dependente a ser modelada.
#' @param horizon Horizonte de previsão.
#' @param n_lags Número de defasagens a serem usadas na modelagem.
#' @return Uma lista contendo as previsões do modelo de Random Forest e informações sobre o modelo ajustado.
#'
#' @examples
#' results <- get_rf(ind = 1:100, df = my_data, variable = "sales", horizon = 10, n_lags = 4)
library(caret)
library(randomForest)
# Preparação dos dados (mesmo estilo do boosting)
data_in <- dataprep(
type = 'default',
ind = ind,
df = df,
variable = variable,
horizon = horizon,
n_lags = n_lags
)
y_in <- as.numeric(data_in$y_in)
x_in <- as.data.frame(data_in$x_in)
x_out <- as.data.frame(data_in$x_out)
x_out <- x_out[, colnames(x_in), drop = FALSE]
# CV setup
set.seed(100)
ctrl <- trainControl(method = "cv", number = 5)
p <- ncol(x_in)
grid <- expand.grid(
mtry = unique(pmax(1, c(1L, floor(sqrt(p)), floor(p/3), floor(p/2), p)))
)
# Ajuste do modelo com CV
rf_cv <- train(
x = x_in,
y = y_in,
method = "rf",
trControl = ctrl,
tuneGrid = grid,
ntree = 500,
metric = "RMSE"
)
if (isTRUE(verbose)) {
print(rf_cv$bestTune)
}
# Previsão
rf_forecast <- predict(rf_cv, newdata = x_out)
# Saída
results <- list(
forecast = as.numeric(rf_forecast),
outputs = list(
rf_cv = rf_cv,
best_mtry = rf_cv$bestTune$mtry
)
)
return(results)
}
source("~/GitHub/gdp-forecasting-with-ML/07_call_Model.R", echo=TRUE)
source("~/GitHub/gdp-forecasting-with-ML/06_get_Models.R", echo=TRUE)
source("~/GitHub/gdp-forecasting-with-ML/05_get_Rolling_Window.R", echo=TRUE)
source("~/GitHub/gdp-forecasting-with-ML/04_get_Data_Prep.R", echo=TRUE)
message("SARIMA")
# Benchmark (SARIMA)
benchmark = call_models(dataset, 'Sarima', get_sarima, "pib_rs")
message("LASSO")
# Lasso model
lasso_model = call_models(dataset, 'Lasso', get_lasso, "pib_rs")
message("Elastic Net")
# Elastic net model
enet_model = call_models(dataset, 'Enet', get_elasticnet, "pib_rs")
message("Random Forest")
# Random Forest model
rf_model1 = call_models(dataset, 'RandomForestOOB', get_rforest, "pib_rs")
rf_model2 = call_models(dataset, 'RandomForestCV', get_rf, "pib_rs")
View(data_m)
