nwindow = nwindows + i - 1,
horizon = i,
variable = variable,
n_lags = 4
)
model_list[[i]] <- model
cat(i, "\n")
}
forecasts <- Reduce(
f = cbind,
x = lapply(model_list, function(x) head(x$forecast, nwindows))
) %>% as.matrix()
for (i in for_ind) {
filename <- paste0("forecast ",model_name,"-horizon-" , i, ".png")
png(filename, width = 1000, height = 600)
col_idx <- match(i, for_ind)  # find which column corresponds to horizon i
plot.ts(y_out,
main = paste0("Forecast with ", model_name, " (horizon = ", i, ")"),
lwd = 2)
lines(forecasts[, col_idx], col = 2, lwd = 2)
dev.off()
}
rmse <- apply(forecasts, 2, f_rmse, y = y_out) %>% print()
mae = apply(forecasts, 2, f_mae, y = y_out) %>% print()
results = list(mae = mae, rmse = rmse, forecasts = forecasts)
return(results)
}
# Sarima model
#sarima_model <- call_models(df, 'Sarima (test)', get_sarima, "y")
sarima_model <- call_models(dataset, 'Sarima', get_sarima, "pib_rs")
call_models = function(data, model_name, model_function, variable, type = "default"){
#' Chamadas para Modelos de Previsão
#'
#' Esta função aplica um modelo de previsão a um conjunto de dados, utilizando uma janela deslizante para gerar previsões.
#'
#' @param data Um `data.frame` ou matriz contendo os dados a serem modelados.
#' @param model_name O nome do modelo a ser utilizado (apenas um rótulo).
#' @param model_function A função que implementa o modelo de previsão a ser aplicado.
#' @param variable O nome da variável dependente que será prevista.
#' @param type O tipo de dados. O padrão é "default".
#' @return Uma lista contendo os seguintes elementos:
#' - mae: O erro absoluto médio das previsões.
#' - rmse: A raiz do erro quadrático médio das previsões.
#' - forecasts: As previsões geradas pelo modelo para o horizonte definido.
#'
#' @examples
#' df <- data.frame(time = 1:100, variable = rnorm(100))
#' results <- call_models(data = df, model_name = "MyModel", model_function = my_model_function, variable = "variable")
#'
#' @export
data = as.matrix(data)
model_name <- model_name
model_function <- model_function
nwindows = round(nrow(data)*0.3)
y_out <- tail(data[, variable], nwindows)
#if (type == 'tb'){
#  data <- as.data.frame(data) %>%
#    select(-c(1)) %>%
#    as.matrix()
#}
model_list <- list()
for_ind <- c(1, 4)
for (i in for_ind) {
model <- rolling_window(
fn = model_function,
df = data,
nwindow = nwindows + i - 1,
horizon = i,
variable = variable,
n_lags = 4
)
model_list[[i]] <- model
cat(i, "\n")
}
forecasts <- Reduce(
f = cbind,
x = lapply(model_list, function(x) head(x$forecast, nwindows))
) %>% as.matrix()
for (i in for_ind) {
filename <- paste0("forecast ",model_name,"-horizon-" , i, ".png")
filepath <- file.path("Plots", filename)
png(filepath, width = 1000, height = 600)
col_idx <- match(i, for_ind)  # find which column corresponds to horizon i
plot.ts(y_out,
main = paste0("Forecast with ", model_name, " (horizon = ", i, ")"),
lwd = 2)
lines(forecasts[, col_idx], col = 2, lwd = 2)
dev.off()
}
rmse <- apply(forecasts, 2, f_rmse, y = y_out) %>% print()
mae = apply(forecasts, 2, f_mae, y = y_out) %>% print()
results = list(mae = mae, rmse = rmse, forecasts = forecasts)
return(results)
}
# Sarima model
#sarima_model <- call_models(df, 'Sarima (test)', get_sarima, "y")
sarima_model <- call_models(dataset, 'Sarima', get_sarima, "pib_rs")
message("LASSO")
# Lasso model
lasso_model <- call_models(dataset, 'Lasso', get_lasso, "pib_rs")
# h=1 RMSE: 0.05619033; MAE: 0.06089886
# h=4 RMSE: 0.03669128; MAE: 0.04466303
message("Elastic Net")
# Elastic net model
enet_model <- call_models(dataset, 'Enet', get_elasticnet, "pib_rs")
View(lasso_model)
lassoh1 <- data.frame(date = tail(date, 28), original = tail(dataset[, 1], 28), predito = lasso_model$forecasts[,1])
lassoh4 <- data.frame(date = tail(date, 28), original = tail(dataset[, 1], 28), predito = lasso_model$forecasts[,2])
matplot(lassoh1$date, lassoh1[, c("orig_recon", "pred_recon")],
type = "l", lty = 1, lwd = 2, col = c("black","red"),
ylab = "Value", xlab = "Date", main = "LASSO - Observed vs Forecast")
lassoh1 <- data.frame(date = tail(date, 28), original = tail(dataset[, 1], 28), predito = lasso_model$forecasts[,1])
lassoh4 <- data.frame(date = tail(date, 28), original = tail(dataset[, 1], 28), predito = lasso_model$forecasts[,2])
# anchor (value before first diff row)
y0 <- 129.1651999
log_y0 <- log(y0)
z_orig  <- lassoh1$original
z_pred  <- lassoh1$predito
# undo differencing: cumulative sum starting at log(y0)
log_recon_orig <- log_y0 + cumsum(z_orig)
log_recon_pred <- log_y0 + cumsum(z_pred)
# undo log
y_recon_orig <- exp(log_recon_orig)
y_recon_pred <- exp(log_recon_pred)
# add back to dataframe
lassoh1$orig_recon  <- y_recon_orig
lassoh1$pred_recon  <- y_recon_pred
plot(tail(data_q[,2], 28), lassoh1$orig_recon)
matplot(lassoh1$date, lassoh1[, c("orig_recon", "pred_recon")],
type = "l", lty = 1, lwd = 2, col = c("black","red"),
ylab = "Value", xlab = "Date", main = "LASSO - Observed vs Forecast")
eneth1 <- data.frame(date = tail(date, 28), original = tail(dataset[, 1], 28), predito = enet_model$forecasts[,1])
eneth4 <- data.frame(date = tail(date, 28), original = tail(dataset[, 1], 28), predito = enet_model$forecasts[,2])
# anchor (value before first diff row)
y0 <- 129.1651999
log_y0 <- log(y0)
z_orig  <- eneth1$original
z_pred  <- eneth1$predito
# undo differencing: cumulative sum starting at log(y0)
log_recon_orig <- log_y0 + cumsum(z_orig)
log_recon_pred <- log_y0 + cumsum(z_pred)
# undo log
y_recon_orig <- exp(log_recon_orig)
y_recon_pred <- exp(log_recon_pred)
# add back to dataframe
eneth1$orig_recon  <- y_recon_orig
eneth1$pred_recon  <- y_recon_pred
plot(tail(data_q[,2], 28), eneth1$orig_recon)
matplot(eneth1$date, eneth1[, c("orig_recon", "pred_recon")],
type = "l", lty = 1, lwd = 2, col = c("black","red"),
ylab = "Value", xlab = "Date", main = "enet - Observed vs Forecast")
get_lasso = function(ind, df, variable, horizon, n_lags){
#' Ajuste de Modelo Lasso
#'
#' Esta função ajusta um modelo de regressão Lasso aos dados fornecidos e gera previsões.
#'
#' @param ind Índices das observações a serem utilizadas.
#' @param df Um data.frame contendo os dados.
#' @param variable Nome da variável dependente a ser modelada.
#' @param horizon Horizonte de previsão.
#' @param n_lags Número de defasagens a serem usadas na modelagem.
#' @return Uma lista contendo as previsões do modelo Lasso.
#'
#' @examples
#' results <- get_lasso(ind = 1:100, df = my_data, variable = "sales", horizon = 10, n_lags = 4)
set.seed(100)
library(glmnet)
library(forecast)
#PREPARANDO OS DADOS
data_in = dataprep(
type = 'default',
#type = 'tb',
ind = ind,
df = df,
variable = variable,
horizon = horizon,
n_lags = 4)
#INICIANDO AS VARIAVEIS
y_in = data_in$y_in
x_in = data_in$x_in
x_out = data_in$x_out
#ESTIMANDO O MODELO
cv_lasso = cv.glmnet(
x = as.matrix(x_in),
y = y_in,
alpha = 1,
intercept = T,
standardize = T,
nfolds = 5)
grid <- 10^seq(10, -2, length = 100)
out = glmnet(x_in, y_in, alpha = 1, lambda = grid)
lasso.coef = predict(
out,
type = "coefficients",
s = cv_lasso$lambda.min)[1:41,]
coef_mat <- as.matrix(lasso.coef)                     # ensure it's a matrix
coef_vals <- as.numeric(coef_mat)                     # numeric values
coef_names <- rownames(coef_mat)                      # names (intercept + features)
nonzero <- which(coef_vals != 0)
# window identifier (keeps track of which rolling window produced it)
window_id <- paste0("ind_", min(ind), "_to_", max(ind))
if (length(nonzero) > 0) {
df_coefs <- data.frame(
window = window_id,
name   = coef_names[nonzero],
coef   = coef_vals[nonzero],
stringsAsFactors = FALSE
)
} else {
df_coefs <- data.frame(
window = window_id,
name   = NA_character_,
coef   = NA_real_,
stringsAsFactors = FALSE
)
}
# store in a global R object (list) so each call appends
if (!exists("lasso_coefs_history", envir = .GlobalEnv)) {
assign("lasso_coefs_history", list(), envir = .GlobalEnv)
}
hist_list <- get("lasso_coefs_history", envir = .GlobalEnv)
hist_list[[length(hist_list) + 1]] <- df_coefs
assign("lasso_coefs_history", hist_list, envir = .GlobalEnv)
# also append to CSV so you can open it later without R running
fn <- "lasso_coefs_history.csv"
write.table(
df_coefs,
file = fn,
sep = ",",
row.names = FALSE,
col.names = !file.exists(fn),
append = TRUE
)
# (optional) still print a short summary to console:
message("Saved ", nrow(df_coefs), " nonzero coef(s) for window ", window_id)
#PREVISAO
opt_lasso = predict(
cv_lasso,
s = cv_lasso$lambda.min,
newx = as.matrix(x_out, nrow = 1))
results = list(forecast = opt_lasso)
return(results)
}
# Lasso model
lasso_model <- call_models(dataset, 'Lasso', get_lasso, "pib_rs")
View(lasso_coefs_history)
lasso_coefs_history[[1]]
lasso_coefs_history[[2]]
lasso_coefs_history[[3]]
lasso_coefs_history[[4]]
lasso_coefs_history[[5]]
lasso_coefs_history[[9]]
lasso_coefs_history[[11]]
lasso_coefs_history[[13]]
lasso_coefs_history[[38]]
lasso_coefs_history[[39]]
lasso_coefs_history[[40]]
lasso_coefs_history[[55]]
lasso_coefs_history[[58]]
lasso_coefs_history[[9]]
get_sarima = function(ind, df, variable, horizon, n_lags){
#' Ajuste de Modelo SARIMA
#'
#' Esta função ajusta um modelo SARIMA aos dados fornecidos e gera previsões.
#'
#' @param ind Índices das observações a serem utilizadas.
#' @param df Um data.frame contendo os dados.
#' @param variable Nome da variável dependente a ser modelada.
#' @param horizon Horizonte de previsão.
#' @param n_lags Número de defasagens a serem usadas na modelagem.
#' @return Uma lista contendo as previsões do modelo SARIMA.
#'
#' @examples
#' results <- get_sarima(ind = 1:100, df = my_data, variable = "sales", horizon = 10, n_lags = 4)
library(tidyverse)
library(forecast)
data_in = dataprep(
ind = ind,
df = df,
variable = variable,
horizon = horizon,
n_lags = n_lags)
#INICIANDO AS VARIAVEIS
y_in = data_in$y_in
reg_arima = auto.arima(
y = y_in,
stepwise = F,
approximation = F,
stationary = T,
seasonal = T,
start.p = 0,
start.q = 0)
print(reg_arima)
for_arima_aux = forecast(
object = reg_arima,
h = horizon)
forecasts = for_arima_aux$mean
results = list(forecasts = forecasts)
return (results)
}
# Sarima model
#sarima_model <- call_models(df, 'Sarima (test)', get_sarima, "y")
sarima_model <- call_models(dataset, 'Sarima', get_sarima, "pib_rs")
get_sarima = function(ind, df, variable, horizon, n_lags){
#' Ajuste de Modelo SARIMA
#'
#' Esta função ajusta um modelo SARIMA aos dados fornecidos e gera previsões.
#'
#' @param ind Índices das observações a serem utilizadas.
#' @param df Um data.frame contendo os dados.
#' @param variable Nome da variável dependente a ser modelada.
#' @param horizon Horizonte de previsão.
#' @param n_lags Número de defasagens a serem usadas na modelagem.
#' @return Uma lista contendo as previsões do modelo SARIMA.
#'
#' @examples
#' results <- get_sarima(ind = 1:100, df = my_data, variable = "sales", horizon = 10, n_lags = 4)
library(tidyverse)
library(forecast)
data_in = dataprep(
ind = ind,
df = df,
variable = variable,
horizon = horizon,
n_lags = n_lags)
#INICIANDO AS VARIAVEIS
y_in = data_in$y_in
reg_arima = auto.arima(
y = y_in,
stepwise = F,
approximation = F,
stationary = F,
seasonal = T,
start.p = 0,
start.q = 0)
print(reg_arima)
for_arima_aux = forecast(
object = reg_arima,
h = horizon)
forecasts = for_arima_aux$mean
results = list(forecasts = forecasts)
return (results)
}
get_elasticnet <- function(ind, df, variable, horizon, n_lags) {
#' Ajuste de Modelo Elastic Net
#'
#' Esta função ajusta um modelo Elastic Net aos dados fornecidos e gera previsões.
#'
#' @param ind Índices das observações a serem utilizadas.
#' @param df Um data.frame contendo os dados.
#' @param variable Nome da variável dependente a ser modelada.
#' @param horizon Horizonte de previsão.
#' @param n_lags Número de defasagens a serem usadas na modelagem.
#' @return Uma lista contendo as previsões do modelo Elastic Net.
#'
#' @examples
#' re
library(forecast)
library(glmnet)
library(caret)
# PREPARANDO OS DADOS
data_in <- dataprep(
type = 'default',
#type = 'tb',
ind = ind,
df = df,
variable = variable,
horizon = horizon,
n_lags = n_lags
)
# INICIANDO AS VARIAVEIS
y_in <- data_in$y_in
x_in <- data_in$x_in
x_out <- data_in$x_out
set.seed(100)
cv_5 <- trainControl(method = "cv", number = 5) # CROSS VALIDATION
myGrid <- expand.grid(
alpha = seq(0, 1, length = 10), # range for alpha
lambda = exp(seq(from = log(0.5), to = log(25000), length = 200)) # Broad range for lambda
)
cv_enet <- train(
x = as.data.frame(x_in),
y = as.numeric(y_in),
method = "glmnet",
trControl = cv_5,
tuneGrid = myGrid,
metric = "RMSE",
intercept = T,
standardize = T
)
# Assuming 'cv_enet' is your trained model object
# best_lambda <- cv_enet$finalModel$lambdaOpt %>% print()
# best_alpha <- cv_enet$finalModel$tuneValue[1] %>% as.numeric() %>% print()
best_lambda <- cv_enet$finalModel$lambdaOpt
best_alpha  <- as.numeric(cv_enet$finalModel$tuneValue[1])
opt_enet <- coef(cv_enet$finalModel, cv_enet$finalModel$lambdaOpt)
#---
coef_mat <- as.matrix(opt_enet)
coef_vals <- as.numeric(coef_mat)
coef_names <- rownames(coef_mat)
nonzero <- which(coef_vals != 0)
# identifier for the rolling window
window_id <- paste0("ind_", min(ind), "_to_", max(ind))
if (length(nonzero) > 0) {
df_coefs <- data.frame(
window = window_id,
name   = coef_names[nonzero],
coef   = coef_vals[nonzero],
alpha  = best_alpha,
lambda = best_lambda,
stringsAsFactors = FALSE
)
} else {
df_coefs <- data.frame(
window = window_id,
name   = NA_character_,
coef   = NA_real_,
alpha  = best_alpha,
lambda = best_lambda,
stringsAsFactors = FALSE
)
}
# store in a global list so each call appends (no change to function signature)
if (!exists("elasticnet_coefs_history", envir = .GlobalEnv)) {
assign("elasticnet_coefs_history", list(), envir = .GlobalEnv)
}
hist_list <- get("elasticnet_coefs_history", envir = .GlobalEnv)
hist_list[[length(hist_list) + 1]] <- df_coefs
assign("elasticnet_coefs_history", hist_list, envir = .GlobalEnv)
# also append to CSV for persistence
fn <- "elasticnet_coefs_history.csv"
write.table(
df_coefs,
file = fn,
sep = ",",
row.names = FALSE,
col.names = !file.exists(fn),
append = TRUE
)
message("Saved ", nrow(df_coefs), " coeff row(s) for window ", window_id)
#---
x <- rep(0, ncol(x_in) + 1)
x[opt_enet@i + 1] <- opt_enet@x
names(x) <- c("cte", colnames(x_in))
glmnet_aux <- glmnet(
x = x_in,
y = y_in,
family = "gaussian",
lambda = best_lambda,
alpha = best_alpha,
standardize = T,
intercept = T
)
opt_elasticnet <- predict(
glmnet_aux,
s = best_lambda,
newx = x_out,
type = "response"
) # acho que retorna "the fitted values"
results <- list(forecast = opt_elasticnet)
return(results)
}
enet_model <- call_models(dataset, 'Enet', get_elasticnet, "pib_rs")
View(elasticnet_coefs_history)
elasticnet_coefs_history[[1]]
elasticnet_coefs_history[[3]]
elasticnet_coefs_history[[3]]
elasticnet_coefs_history[[36]]
revert_diff_log <- function(y0, df, series, withdate=TRUE){
proc_cols <- if (withdate) names(df)[-1] else names(df)
n_proc <- length(proc_cols)
log_y0 <- log(y0)
out_df <- df
for (col_name in proc_cols) {
z <- as.numeric(df[[col_name]])
if (anyNA(z)) warning("NA values in column '", col_name, "'; they will propagate in cumsum.")
# undo differencing in log-space
log_recon <- log_y0 + cumsum(z)
# undo log
y_recon <- exp(log_recon)
# add reconstructed column
out_df[[paste0("rev_", col_name)]] <- y_recon
}
rev_cols <- grep("^rev_", names(out_df), value = TRUE)
x <- if (withdate) out_df[[1]] else seq_len(nrow(out_df))
matplot(x,
out_df[, rev_cols, drop = FALSE],
type = "l", lty = 1, lwd = 2,
col = 1:length(rev_cols),
main = paste0("Reverted series - ",df))
return(out_df)
}
sarimah4 <- revert_diff_log(129.1651999, sarimah4)
revert_diff_log <- function(y0, df, series, withdate=TRUE){
proc_cols <- if (withdate) names(df)[-1] else names(df)
n_proc <- length(proc_cols)
log_y0 <- log(y0)
out_df <- df
for (col_name in proc_cols) {
z <- as.numeric(df[[col_name]])
if (anyNA(z)) warning("NA values in column '", col_name, "'; they will propagate in cumsum.")
# undo differencing in log-space
log_recon <- log_y0 + cumsum(z)
# undo log
y_recon <- exp(log_recon)
# add reconstructed column
out_df[[paste0("rev_", col_name)]] <- y_recon
}
return(out_df)
}
sarimah4 <- revert_diff_log(129.1651999, sarimah4)
View(sarimah4)
