#' Adiciona Estrelas para Indicar Níveis de Significância
#'
#' Esta função atribui estrelas (*) aos valores-p com base em níveis de significância especificados.
#'
#' @param pvalues Um vetor de valores-p.
#' @param alpha_levels Um vetor de níveis de significância (padrão: 0.05, 0.01, 0.001).
#'
#' @return Um vetor de caracteres com estrelas correspondentes aos valores-p.
#'
#' @examples
#' stars <- add_stars(c(0.02, 0.001, 0.07))
#'
stars <- character(length(pvalues))
for (i in seq_along(alpha_levels)) {
stars[pvalues <= alpha_levels[i]] <- paste(rep("*", i), collapse = "")
}
return(stars)
}
compute_dm = function(){
#' Computa o Teste de Diebold-Mariano para Modelos de Previsão
#'
#' Esta função calcula o teste de Diebold-Mariano para diferentes modelos de previsão e horizontes de previsão.
#'
#' @return Uma lista contendo matrizes de valores-p formatadas com estrelas para três conjuntos de modelos:
#'   - pvalues_tb: valores-p para modelos baseados em texto.
#'   - pvalues_eco: valores-p para modelos econômicos.
#'   - pvalues_eco_tb: valores-p para modelos que combinam dados econômicos e baseados em texto.
#'
#' @examples
#' dm_results <- compute_dm()
model_names <- c("LASSO", "Elastic Net", "Random Forest", "Boosting")
horizons <- c(1, 4)
##################################################
############## DM FOR TEXT BASE ##################
##################################################
model_dataframes <- list(lasso_model, enet_model, rf_model, boosting_model)
pvalues <- matrix(nrow = length(model_names), ncol = length(horizons))
results <- list()
results_tb = results
pvalues_tb = pvalues
for (m in seq_along(model_names)) {
model_name <- model_names[m]
model_df <- model_dataframes[[m]]
for (i in seq_along(horizons)) {
h <- horizons[i]
x <- data.frame(benchmark$forecasts)[[i]]
y <- data.frame(model_df$forecasts)[[i]]
#residual = y - ŷ
dm = dm.test(
e1 = dataset$`pib_rs`[65:92] - y,
e2 = dataset$`pib_rs`[65:92] - x,
h = h,
alternative = 'two.sided',
varestimator = 'bartlett'
)
pvalues[m, i] <- dm$p.value
results[[paste0(model_name, '- horizon ', h)]] <- dm
}
}
rownames(pvalues) <- model_names
colnames(pvalues) <- horizons
pvalues_eco_stars <- add_stars(pvalues)
pvalues <- matrix(paste0(format(pvalues, nsmall = 10), pvalues_eco_stars), nrow = nrow(pvalues), dimnames = dimnames(pvalues))
pvalues
#
#
# ##################################################
# ############## DM FOR ECONOMIC ###################
# ##################################################
# model_dataframes <- list(lasso_economic, enet_economic, boosting_economic)
# pvalues <- matrix(nrow = length(model_names), ncol = length(horizons))
# results <- list()
#
# results_eco = results
# pvalues_eco = pvalues
#
# for (m in seq_along(model_names)) {
#   model_name <- model_names[m]
#   model_df <- model_dataframes[[m]]
#
#   for (i in seq_along(horizons)) {
#     h <- horizons[i]
#
#     x <- data.frame(benchmark$forecasts)[[i]]
#     y <- data.frame(model_df$forecasts)[[i]]
#
#     #residual = y - ŷ
#     dm = dm.test(
#       e1 = dataset_economic$`BZEAMOM%`[124:164] - y,
#       e2 = dataset_economic$`BZEAMOM%`[124:164] - x,
#       h = h,
#       alternative = 'two.sided',
#       varestimator = 'bartlett'
#     )
#
#     pvalues_eco[m, i] <- dm$p.value
#     results_eco[[paste0(model_name, "_eco", h)]] <- dm
#   }
# }
#
# rownames(pvalues_eco) <- model_names
# colnames(pvalues_eco) <- horizons
#
# pvalues_eco_stars <- add_stars(pvalues_eco)
# pvalues_eco <- matrix(paste0(format(pvalues_eco, nsmall = 10), pvalues_eco_stars), nrow = nrow(pvalues_eco), dimnames = dimnames(pvalues_eco))
# pvalues_eco
#
#
# ##################################################
# ########GW FOR ECONOMIC AND TEXT BASE ############
# ##################################################
# model_dataframes <- list(lasso_economic_tb, enet_economic_tb, boosting_economic_tb)
# pvalues <- matrix(nrow = length(model_names), ncol = length(horizons))
# results <- list()
#
# results_eco_tb = results
# pvalues_eco_tb = pvalues
#
# for (m in seq_along(model_names)) {
#   model_name <- model_names[m]
#   model_df <- model_dataframes[[m]]
#
#   for (i in seq_along(horizons)) {
#     h <- horizons[i]
#
#     x <- data.frame(benchmark$forecasts)[[i]]
#     y <- data.frame(model_df$forecasts)[[i]]
#
#     dm = dm.test(
#       e1 = dataset_economic$`BZEAMOM%`[124:164] - y,
#       e2 = dataset_economic$`BZEAMOM%`[124:164] - x,
#       h = h,
#       alternative = 'two.sided',
#       varestimator = 'bartlett'
#     )
#
#     pvalues_eco_tb[m, i] <- dm$p.value
#     results_eco_tb[[paste0(model_name, "_eco", h)]] <- dm
#   }
# }
#
# rownames(pvalues_eco_tb) <- model_names
# colnames(pvalues_eco_tb) <- horizons
#
# pvalues_eco_tb_stars <- add_stars(pvalues_eco_tb)
# pvalues_eco_tb <- matrix(paste0(format(pvalues_eco_tb, nsmall = 10), pvalues_eco_tb_stars), nrow = nrow(pvalues_eco_tb), dimnames = dimnames(pvalues_eco_tb))
# pvalues_eco_tb
list = list(
pvalues = pvalues)
return(list)
}
dm_tests = compute_dm()
View(dm_tests)
dm_tests[["pvalues"]]
compute_dm = function(){
#' Computa o Teste de Diebold-Mariano para Modelos de Previsão
#'
#' Esta função calcula o teste de Diebold-Mariano para diferentes modelos de previsão e horizontes de previsão.
#'
#' @return Uma lista contendo matrizes de valores-p formatadas com estrelas para três conjuntos de modelos:
#'   - pvalues_tb: valores-p para modelos baseados em texto.
#'   - pvalues_eco: valores-p para modelos econômicos.
#'   - pvalues_eco_tb: valores-p para modelos que combinam dados econômicos e baseados em texto.
#'
#' @examples
#' dm_results <- compute_dm()
model_names <- c("LASSO", "Elastic Net", "Random Forest", "Boosting")
horizons <- c(1, 4)
##################################################
############## DM FOR TEXT BASE ##################
##################################################
model_dataframes <- list(lasso_model, enet_model, rf_model, boosting_model)
pvalues <- matrix(nrow = length(model_names), ncol = length(horizons))
results <- list()
results_tb = results
pvalues_tb = pvalues
for (m in seq_along(model_names)) {
model_name <- model_names[m]
model_df <- model_dataframes[[m]]
for (i in seq_along(horizons)) {
h <- horizons[i]
x <- data.frame(benchmark$forecasts)[[i]]
y <- data.frame(model_df$forecasts)[[i]]
#residual = y - ŷ
dm = dm.test(
e1 = dataset$`pib_rs`[65:92] - y,
e2 = dataset$`pib_rs`[65:92] - x,
h = h,
alternative = 'two.sided',
varestimator = 'bartlett'
)
pvalues[m, i] <- dm$p.value
results[[paste0(model_name, '- horizon ', h)]] <- dm
}
}
rownames(pvalues) <- model_names
colnames(pvalues) <- horizons
pvalues_eco_stars <- add_stars(pvalues)
pvalues <- matrix(paste0(format(pvalues, nsmall = 10), pvalues_eco_stars), nrow = nrow(pvalues), dimnames = dimnames(pvalues))
pvalues
list = list(
pvalues = pvalues)
return(list)
}
compute_dmv2 = function(){
#' Computa o Teste de Diebold-Mariano para Modelos de Previsão
#'
#' Esta função calcula o teste de Diebold-Mariano para diferentes modelos de previsão e horizontes de previsão.
#'
#' @return Uma lista contendo matrizes de valores-p formatadas com estrelas para três conjuntos de modelos:
#'   - pvalues_tb: valores-p para modelos baseados em texto.
#'   - pvalues_eco: valores-p para modelos econômicos.
#'   - pvalues_eco_tb: valores-p para modelos que combinam dados econômicos e baseados em texto.
#'
#' @examples
#' dm_results <- compute_dm()
model_names <- c("LASSO", "Elastic Net", "Random Forest", "Boosting")
horizons <- c(1, 4)
##################################################
############## DM FOR TEXT BASE ##################
##################################################
model_dataframes <- list(lasso_model, enet_model, rf_model, boosting_model)
pvalues <- matrix(nrow = length(model_names), ncol = length(horizons))
results <- list()
results_tb = results
pvalues_tb = pvalues
for (m in seq_along(model_names)) {
model_name <- model_names[m]
model_df <- model_dataframes[[m]]
for (i in seq_along(horizons)) {
h <- horizons[i]
x <- data.frame(mean_model$forecasts)[[i]]
y <- data.frame(model_df$forecasts)[[i]]
#residual = y - ŷ
dm = dm.test(
e1 = dataset$`pib_rs`[65:92] - y,
e2 = dataset$`pib_rs`[65:92] - x,
h = h,
alternative = 'two.sided',
varestimator = 'bartlett'
)
pvalues[m, i] <- dm$p.value
results[[paste0(model_name, '- horizon ', h)]] <- dm
}
}
rownames(pvalues) <- model_names
colnames(pvalues) <- horizons
pvalues_eco_stars <- add_stars(pvalues)
pvalues <- matrix(paste0(format(pvalues, nsmall = 10), pvalues_eco_stars), nrow = nrow(pvalues), dimnames = dimnames(pvalues))
pvalues
list = list(
pvalues = pvalues)
return(list)
}
meandm_test = compute_dmv2()
meandm_test[["pvalues"]]
csfe = function(model, benchmark, y_real){
#' Calcula CSFE para Diferentes Horizontes
#'
#' Esta função calcula o Cumulative Squared Forecast Error (CSFE) para diferentes horizontes de previsão
#' a partir das previsões de um modelo e de um benchmark.
#'
#' @param model Um objeto contendo as previsões do modelo, com colunas representando diferentes horizontes.
#' @param benchmark Um objeto contendo as previsões do benchmark, com colunas correspondendo aos mesmos horizontes.
#' @param y_real Um vetor numérico contendo os valores reais observados.
#' @return Uma matriz com os erros quadráticos acumulados para cada horizonte de previsão.
#'
#' @examples
#' csfe_results <- csfe(model, benchmark, y_real)
#' print(csfe_results)
#'
h1 = f_csfe(model$forecast[,1], benchmark$forecasts[,1], y_real = y_real)
h4 = f_csfe(model$forecast[,2], benchmark$forecasts[,2], y_real = y_real)
cbind(h1, h4)
}
f_csfe <- function(x, y_bench, y_real) {
#' Calcula o Cumulative Squared Forecast Error (CSFE)
#'
#' Esta função calcula o erro quadrático acumulado da previsão em relação a um benchmark e
#' os valores reais. O resultado permite avaliar a precisão do modelo em comparação com o benchmark.
#'
#' @param x Um vetor numérico contendo as previsões do modelo.
#' @param y_bench Um vetor numérico contendo as previsões do benchmark.
#' @param y_real Um vetor numérico contendo os valores reais observados.
#' @return Um vetor numérico que contém o erro quadrático acumulado para cada ponto no tempo.
#'
#' @examples
#' f_csfe(c(1, 2, 3), c(1.5, 2.5, 3.5), c(1, 2, 3)) # Retorna o erro quadrático acumulado
#'
error_bench <- (y_bench - y_real)^2
error_x <- (x - y_real)^2
result <- cumsum(error_bench - error_x)
return(result)
}
csfe_lasso = csfe(lasso_model, benchmark, dataset$"pib_rs"[65:92])
csfe_enet = csfe(enet_model, benchmark, dataset$"pib_rs"[65:92])
csfe_rf = csfe(rf_model, benchmark, dataset$"pib_rs"[65:92])
csfe_boosting = csfe(boosting_model, benchmark, dataset$"pib_rs"[65:92])
View(csfe_lasso)
names(cfse_lasso)[1:2] <- c("LASSO_h1", "LASSO_h4")
names(csfe_lasso)[1:2] <- c("LASSO_h1", "LASSO_h4")
View(csfe_lasso)
View(csfe_boosting)
names(csfe_lasso)[names(csfe_lasso) == "h1"] <- "LASSO_h1"
names(csfe_lasso)[names(csfe_lasso) == "h4"] <- "LASSO_h4"
names(csfe_enet)[names(csfe_enet) == "h1"] <- "enet_h1"
names(csfe_enet)[names(csfe_enet) == "h4"] <- "enet_h4"
names(csfe_rf)[names(csfe_rf) == "h1"] <- "rf_h1"
names(csfe_rf)[names(csfe_rf) == "h4"] <- "rf_h4"
names(csfe_boosting)[names(csfe_boosting) == "h1"] <- "boosting_h1"
names(csfe_boosting)[names(csfe_boosting) == "h4"] <- "boosting_h4"
CSFE <- data.frame(csfe_lasso, csfe_enet, csfe_rf, csfe_boosting)
View(CSFE)
plot(csfe_lasso[[h1]], type="l")
plot(csfe_lasso, type="l")
plot(csfe_lasso$h1, type="l")
plot(csfe_lasso[[1]], type="l")
csfe_lasso <- as.data.frame(csfe_lasso)
plot(csfe_lasso$h1, type="l")
csfe_enet <- as.data.frame(csfe_enet)
csfe_rf <- as.data.frame(csfe_rf)
csfe_boosting <- as.data.frame(csfe_boosting)
plot(csfe_lasso$h4, type="l")
plot(csfe_enet$h1, type="l")
plot(csfe_rf$h1, type="l")
plot(csfe_boosting$h1, type="l")
plot(csfe_lasso$h4, type="l")
plot(csfe_enet$h4, type="l")
plot(csfe_rf$h4, type="l")
plot(csfe_boosting$h4, type="l")
CSFE <- cbind(csfe_lasso, csfe_enet, csfe_rf, csfe_boosting)
View(CSFE)
plot(csfe_boosting$h1, type="l")
plot(csfe_lasso$h1, type = "l", col = "orange", lwd = 2,
ylab = "h1", xlab = "Index", main = "Comparison of h1 across models")
lines(csfe_enet$h1, col = "red",   lwd = 2)
lines(csfe_rf$h1,   col = "blue",  lwd = 2)
lines(csfe_boosting$h1, col = "green", lwd = 2)
legend("topright",
legend = c("Lasso", "Elastic Net", "Random Forest", "Boosting"),
col = c("orange", "red", "blue", "green"),
lty = 1, lwd = 2)
plot(csfe_lasso$h4, type = "l", col = "orange", lwd = 2,
ylab = "h4", xlab = "Index", main = "Comparison of h1 across models")
lines(csfe_enet$h4, col = "red",   lwd = 2)
lines(csfe_rf$h4,   col = "blue",  lwd = 2)
lines(csfe_boosting$h4, col = "green", lwd = 2)
legend("topright",
legend = c("Lasso", "Elastic Net", "Random Forest", "Boosting"),
col = c("orange", "red", "blue", "green"),
lty = 1, lwd = 2)
plot(csfe_lasso$h4, type = "l", col = "orange", lwd = 2,
ylab = "h4", xlab = "Index", main = "Comparison of h4 across models")
lines(csfe_enet$h4, col = "red",   lwd = 2)
lines(csfe_rf$h4,   col = "blue",  lwd = 2)
lines(csfe_boosting$h4, col = "green", lwd = 2)
legend("topleft",
legend = c("Lasso", "Elastic Net", "Random Forest", "Boosting"),
col = c("orange", "red", "blue", "green"),
lty = 1, lwd = 2)
# Base R plotting
plot(date[65:92], csfe_lasso$h4, type = "l", col = "orange", lwd = 2,
ylab = "h4", xlab = "Index", main = "Comparison of h4 across models")
lines(date[65:92], csfe_enet$h4, col = "red",   lwd = 2)
lines(date[65:92], csfe_rf$h4,   col = "blue",  lwd = 2)
lines(date[65:92], csfe_boosting$h4, col = "green", lwd = 2)
legend("topleft",
legend = c("Lasso", "Elastic Net", "Random Forest", "Boosting"),
col = c("orange", "red", "blue", "green"),
lty = 1, lwd = 2)
legend("top",
legend = c("Lasso", "Elastic Net", "Random Forest", "Boosting"),
col = c("orange", "red", "blue", "green"),
lty = 1, lwd = 2)
plot(date[65:92], csfe_lasso$h4, type = "l", col = "orange", lwd = 2,
ylab = "h4", xlab = "Index", main = "Comparison of h4 across models")
lines(date[65:92], csfe_enet$h4, col = "red",   lwd = 2)
lines(date[65:92], csfe_rf$h4,   col = "blue",  lwd = 2)
lines(date[65:92], csfe_boosting$h4, col = "green", lwd = 2)
legend("top",
legend = c("Lasso", "Elastic Net", "Random Forest", "Boosting"),
col = c("orange", "red", "blue", "green"),
lty = 1, lwd = 2)
legend("topleft",
legend = c("Lasso", "Elastic Net", "Random Forest", "Boosting"),
col = c("orange", "red", "blue", "green"),
lty = 1, lwd = 2)
plot(date[65:92], csfe_lasso$h4, type = "l", col = "orange", lwd = 2,
ylab = "h4", xlab = "Index", main = "Comparison of h4 across models")
lines(date[65:92], csfe_enet$h4, col = "red",   lwd = 2)
lines(date[65:92], csfe_rf$h4,   col = "blue",  lwd = 2)
lines(date[65:92], csfe_boosting$h4, col = "green", lwd = 2)
legend("topleft",
legend = c("Lasso", "Elastic Net", "Random Forest", "Boosting"),
col = c("orange", "red", "blue", "green"),
lty = 1, lwd = 2)
plot(date[65:92], csfe_lasso$h1, type = "l", col = "orange", lwd = 2,
ylab = "h1", xlab = "Index", main = "Comparison of h1 across models")
lines(date[65:92], csfe_enet$h1, col = "red",   lwd = 2)
lines(date[65:92], csfe_rf$h1,   col = "blue",  lwd = 2)
lines(date[65:92], csfe_boosting$h1, col = "green", lwd = 2)
legend("topright",
legend = c("Lasso", "Elastic Net", "Random Forest", "Boosting"),
col = c("orange", "red", "blue", "green"),
lty = 1, lwd = 2)
plot(date[65:92], csfe_lasso$h1, type = "l", col = "orange", lwd = 2,
ylab = "h1", xlab = "Index", main = "Comparison of h1 across models")
lines(date[65:92], csfe_enet$h1, col = "red",   lwd = 2)
lines(date[65:92], csfe_rf$h1,   col = "blue",  lwd = 2)
lines(date[65:92], csfe_boosting$h1, col = "green", lwd = 2)
legend("topleft",
legend = c("Lasso", "Elastic Net", "Random Forest", "Boosting"),
col = c("orange", "red", "blue", "green"),
lty = 1, lwd = 2)
plot(date[65:92], csfe_lasso$h1, type = "l", col = "orange", lwd = 2, ylim = c(0, 0.06),
ylab = "h1", xlab = "Index", main = "Comparison of h1 across models")
lines(date[65:92], csfe_enet$h1, col = "red",   lwd = 2)
lines(date[65:92], csfe_rf$h1,   col = "blue",  lwd = 2)
lines(date[65:92], csfe_boosting$h1, col = "green", lwd = 2)
plot(date[65:92], csfe_lasso$h1, type = "l", col = "orange", lwd = 2, ylim = c(0, 0.056),
ylab = "h1", xlab = "Index", main = "Comparison of h1 across models")
lines(date[65:92], csfe_enet$h1, col = "red",   lwd = 2)
lines(date[65:92], csfe_rf$h1,   col = "blue",  lwd = 2)
lines(date[65:92], csfe_boosting$h1, col = "green", lwd = 2)
plot(date[65:92], csfe_lasso$h1, type = "l", col = "orange", lwd = 2, ylim = c(-0.01, 0.056),
ylab = "h1", xlab = "Index", main = "Comparison of h1 across models")
lines(date[65:92], csfe_enet$h1, col = "red",   lwd = 2)
lines(date[65:92], csfe_rf$h1,   col = "blue",  lwd = 2)
lines(date[65:92], csfe_boosting$h1, col = "green", lwd = 2)
legend("topleft",
legend = c("Lasso", "Elastic Net", "Random Forest", "Boosting"),
col = c("orange", "red", "blue", "green"),
lty = 1, lwd = 2)
plot(date[65:92], csfe_lasso$h4, type = "l", col = "orange", lwd = 2,
ylab = "h4", xlab = "Index", main = "Comparison of h4 across models")
lines(date[65:92], csfe_enet$h4, col = "red",   lwd = 2)
lines(date[65:92], csfe_rf$h4,   col = "blue",  lwd = 2)
lines(date[65:92], csfe_boosting$h4, col = "green", lwd = 2)
legend("topleft",
legend = c("Lasso", "Elastic Net", "Random Forest", "Boosting"),
col = c("orange", "red", "blue", "green"),
lty = 1, lwd = 2)
plot(date[65:92], csfe_lasso$h4, type = "l", col = "orange", lwd = 2, ylim = c(0.05, 0.04),
ylab = "h4", xlab = "Index", main = "Comparison of h4 across models")
lines(date[65:92], csfe_enet$h4, col = "red",   lwd = 2)
lines(date[65:92], csfe_rf$h4,   col = "blue",  lwd = 2)
lines(date[65:92], csfe_boosting$h4, col = "green", lwd = 2)
legend("topleft",
legend = c("Lasso", "Elastic Net", "Random Forest", "Boosting"),
col = c("orange", "red", "blue", "green"),
lty = 1, lwd = 2)
benchmark <- call_models(dataset, 'SARIMA', get_sarima, "pib_rs")
lasso_model <- call_models(dataset, 'LASSO', get_lasso, "pib_rs")
View(dataset)
library(dplyr)
library(lubridate)
source("02_get_Stationary_SW.R")
source("03_get_Quarterly_Data.R")
source("04_get_Data_Prep.R")
source("05_get_Rolling_Window.R")
source("06_get_Models.R")
source("07_call_Model.R")
# ================================================
# ---------------Calling Dataset------------------
# ================================================
message("[1/7] Loading data...")
## ORIGINAL, UNTRANSFORMED DATA.
data_m <- readRDS("Data/base_NSA.rds")
data_q <- read.csv2("Data/quarterly_NSA.csv")
#Transform date column, remove empty rows
data_q$date <- as.Date(data_q$date)
data_m <- data_m[-((nrow(data_m)-1):nrow(data_m)), ]
# ================================================
# --------Preprocessing for Stationarity----------
# ================================================
sw_list <- as.data.frame(read.csv2("Stock_watson.csv"))
message("[2/7] Applying Stock-Watson transforms (monthly)...")
stdata_m <- get_stationary_SW(data_m, sw_list)
info_stm <- stdata_m$info
datamon <- do.call(cbind, stdata_m$results) %>% as.data.frame()
message("[3/7] Applying Stock-Watson transforms (quarterly)...")
stdata_q <- get_stationary_SW(data_q, sw_list)
info_stq <- stdata_q$info
dataqrt <- do.call(cbind, stdata_q$results) %>% as.data.frame()
# ================================================
# --------Transforming to Quarterly data----------
# ================================================
message("[4/7] Aggregating monthly series to quarterly...")
quarter_ds <- aggregate_to_quarterly(stdata_m$results, stdata_m$info)
# ================================================
# --------------Merging datasets------------------
# ================================================
message("[5/7] Merging datasets and building features...")
mq_results <- do.call(cbind, quarter_ds$results) %>% as.data.frame()
mq_results$date <- as.Date(mq_results$date, origin = "1970-01-01")
dataqrt$date <- as.Date(dataqrt$date, origin = "1970-01-01")
dataset <- merge(dataqrt, mq_results, by = "date")
#Adding dummies
dummies <- data.frame(matrix(ncol = 0, nrow = 92))
dummies$quarter <- lubridate::quarter(dataset$date)
dataset$Q2 <- ifelse(dummies$quarter == 2, 1, 0)
dataset$Q3 <- ifelse(dummies$quarter == 3, 1, 0)
dataset$Q4 <- ifelse(dummies$quarter == 4, 1, 0)
dataset$d_pandemic <- ifelse(dataset$date >= as.Date("2020-03-01") &
dataset$date <= as.Date("2020-06-01"), 1, 0)
dataset$d_rsflood <- ifelse(dataset$date == as.Date("2024-06-01"), 1, 0)
date = dataset$date
dataset$date <- NULL
dataset[] <- lapply(dataset, as.numeric)
# --- Making sure data is stationary
message("[6/7] Checking stationarity (ADF ndiffs) on merged dataset...")
lasso_model <- call_models(dataset, 'LASSO', get_lasso, "pib_rs")
