#' results <- call_models(data = df, model_name = "MyModel", model_function = my_model_function, variable = "variable")
#'
#' @export
data = as.matrix(data)
model_name <- model_name
model_function <- model_function
nwindows = nrow(data)*0.25
y_out <- tail(data[, variable], nwindows)
#if (type == 'tb'){
#  data <- as.data.frame(data) %>%
#    select(-c(1)) %>%
#    as.matrix()
#}
model_list <- list()
for_ind <- c(1, 4)
for (i in for_ind) {
model <- rolling_window(
fn = model_function,
df = data,
nwindow = nwindows + i - 1,
horizon = i,
variable = variable,
n_lags = 4
)
model_list[[i]] <- model
cat(i, "\n")
}
forecasts <- Reduce(
f = cbind,
x = lapply(model_list, function(x) head(x$forecast, nwindows))
) %>% as.matrix()
plot.ts(y_out)
lines(forecasts[, 1], col = 2)
rmse <- apply(forecasts, 2, f_rmse, y = y_out) %>% print()
mae = apply(forecasts, 2, f_mae, y = y_out) %>% print()
results = list(mae = mae, rmse = rmse, forecasts = forecasts)
return(results)
}
# Mean model
mean_model <- call_models(df, 'Mean', get_mean, "y")
# Benchmark (SARIMA)
benchmark <- call_models(df, 'Sarima', get_sarima, "y")
traceback()
# Mean model
mean_model <- call_models(df, 'Mean', get_mean, "y")
traceback()
call_models = function(data, model_name, model_function, variable, type = "tb"){
#' Chamadas para Modelos de Previsão
#'
#' Esta função aplica um modelo de previsão a um conjunto de dados, utilizando uma janela deslizante para gerar previsões.
#'
#' @param data Um `data.frame` ou matriz contendo os dados a serem modelados.
#' @param model_name O nome do modelo a ser utilizado (apenas um rótulo).
#' @param model_function A função que implementa o modelo de previsão a ser aplicado.
#' @param variable O nome da variável dependente que será prevista.
#' @param type O tipo de dados. O padrão é "default".
#' @return Uma lista contendo os seguintes elementos:
#' - mae: O erro absoluto médio das previsões.
#' - rmse: A raiz do erro quadrático médio das previsões.
#' - forecasts: As previsões geradas pelo modelo para o horizonte definido.
#'
#' @examples
#' df <- data.frame(time = 1:100, variable = rnorm(100))
#' results <- call_models(data = df, model_name = "MyModel", model_function = my_model_function, variable = "variable")
#'
#' @export
data = as.matrix(data)
model_name <- model_name
model_function <- model_function
nwindows = nrow(data)*0.25
y_out <- tail(data[, variable], nwindows)
#if (type == 'tb'){
#  data <- as.data.frame(data) %>%
#    select(-c(1)) %>%
#    as.matrix()
#}
model_list <- list()
for_ind <- c(1, 4)
for (i in for_ind) {
model <- rolling_window(
fn = model_function,
df = data,
nwindow = nwindows + i - 1,
horizon = i,
variable = variable,
n_lags = 4
)
model_list[[i]] <- model
cat(i, "\n")
}
forecasts <- Reduce(
f = cbind,
x = lapply(model_list, function(x) head(x$forecast, nwindows))
) %>% as.matrix()
print(forecasts)
plot.ts(y_out)
lines(forecasts[, 1], col = 2)
rmse <- apply(forecasts, 2, f_rmse, y = y_out) %>% print()
mae = apply(forecasts, 2, f_mae, y = y_out) %>% print()
results = list(mae = mae, rmse = rmse, forecasts = forecasts)
return(results)
}
# Mean model
mean_model <- call_models(df, 'Mean', get_mean, "y")
date = df$date
df[] <- lapply(df, as.numeric)
df$date <- NULL
call_models = function(data, model_name, model_function, variable, type = "default"){
#' Chamadas para Modelos de Previsão
#'
#' Esta função aplica um modelo de previsão a um conjunto de dados, utilizando uma janela deslizante para gerar previsões.
#'
#' @param data Um `data.frame` ou matriz contendo os dados a serem modelados.
#' @param model_name O nome do modelo a ser utilizado (apenas um rótulo).
#' @param model_function A função que implementa o modelo de previsão a ser aplicado.
#' @param variable O nome da variável dependente que será prevista.
#' @param type O tipo de dados. O padrão é "default".
#' @return Uma lista contendo os seguintes elementos:
#' - mae: O erro absoluto médio das previsões.
#' - rmse: A raiz do erro quadrático médio das previsões.
#' - forecasts: As previsões geradas pelo modelo para o horizonte definido.
#'
#' @examples
#' df <- data.frame(time = 1:100, variable = rnorm(100))
#' results <- call_models(data = df, model_name = "MyModel", model_function = my_model_function, variable = "variable")
#'
#' @export
data = as.matrix(data)
model_name <- model_name
model_function <- model_function
nwindows = nrow(data)*0.25
y_out <- tail(data[, variable], nwindows)
#if (type == 'tb'){
#  data <- as.data.frame(data) %>%
#    select(-c(1)) %>%
#    as.matrix()
#}
model_list <- list()
for_ind <- c(1, 4)
for (i in for_ind) {
model <- rolling_window(
fn = model_function,
df = data,
nwindow = nwindows + i - 1,
horizon = i,
variable = variable,
n_lags = 4
)
model_list[[i]] <- model
cat(i, "\n")
}
forecasts <- Reduce(
f = cbind,
x = lapply(model_list, function(x) head(x$forecast, nwindows))
) %>% as.matrix()
print(forecasts)
plot.ts(y_out)
lines(forecasts[, 1], col = 2)
rmse <- apply(forecasts, 2, f_rmse, y = y_out) %>% print()
mae = apply(forecasts, 2, f_mae, y = y_out) %>% print()
results = list(mae = mae, rmse = rmse, forecasts = forecasts)
return(results)
}
# Mean model
mean_model <- call_models(df, 'Mean', get_mean, "y")
library(dplyr)
library(lubridate)
# Mean model
mean_model <- call_models(df, 'Mean', get_mean, "y")
# Mean model
mean_model <- call_models(df, 'Mean', get_mean, "y")
message("SARIMA")
# Benchmark (SARIMA)
benchmark <- call_models(df, 'Sarima', get_sarima, "y")
warnings()
dataset <- readRDS("dataset.rds")
# ================================================
# ---------------------Main-----------------------
# ================================================
library(dplyr)
library(lubridate)
# ================================================
# ------------------Functions---------------------
# ================================================
source("02_get_Stationary_SW.R")
source("03_get_Quarterly_Data.R")
source("04_get_Data_Prep.R")
source("05_get_Rolling_Window.R")
source("06_get_Models.R")
source("07_call_Model.R")
#rm(setdiff(list(c("ipea", ))))
# ================================================
# ---------------Calling Dataset------------------
# ================================================
message("[1/7] Loading data...")
data_m <- readRDS("Data/base_NSA.rds")
data_q <- read.csv2("Data/quarterly_NSA.csv")
data_q$date <- as.Date(data_q$date)
data_m <- data_m[-((nrow(data_m)-1):nrow(data_m)), ] # remove empty rows
sum(is.na(data_m))
sum(is.na(data_q))
# ================================================
# --------Preprocessing for Stationarity----------
# ================================================
message("[2/7] Applying Stock-Watson transforms (monthly)...")
sw_list <- as.data.frame(read.csv2("Stock_watson.csv"))
message("[3/7] Applying Stock-Watson transforms (quarterly)...")
stdata_m <- get_stationary_SW(data_m, sw_list)
info_stm <- stdata_m$info
datamon <- do.call(cbind, stdata_m$results) %>% as.data.frame()
stdata_q <- get_stationary_SW(data_q, sw_list)
info_stq <- stdata_q$info
dataqrt <- do.call(cbind, stdata_q$results) %>% as.data.frame()
# ================================================
# --------Transforming to Quarterly data----------
# ================================================
message("[4/7] Aggregating monthly series to quarterly...")
quarter_ds <- aggregate_to_quarterly(stdata_m$results, stdata_m$info)
# plot(quarter_ds[["results"]][["bage_precipitacao"]], type = "l") #for list within list
# plot(data_q$pib_rs, type = "l") #for dataframe
# ================================================
# --------------Merging datasets------------------
# ================================================
message("[5/7] Merging datasets and building features...")
mq_results <- do.call(cbind, quarter_ds$results) %>% as.data.frame()
mq_results$date <- as.Date(mq_results$date, origin = "1970-01-01")
dataqrt$date <- as.Date(dataqrt$date, origin = "1970-01-01")
dataset <- merge(dataqrt, mq_results, by = "date")
#Adding dummies
# n_obs <- nrow(dataset)
# dummies <- data.frame(matrix(ncol = 0, nrow = n_obs))
# dummies$quarter <- lubridate::quarter(dataset$date)
# dataset$Q2 <- ifelse(dummies$quarter == 2, 1, 0)
# dataset$Q3 <- ifelse(dummies$quarter == 3, 1, 0)
# dataset$Q4 <- ifelse(dummies$quarter == 4, 1, 0)
# dataset$d_pandemic <- ifelse(dataset$date >= as.Date("2020-03-01") &
#                                dataset$date <= as.Date("2020-06-01"), 1, 0)
# dataset$d_rsflood <- ifelse(dataset$date == as.Date("2024-06-01"), 1, 0)
saveRDS(dataset, "dataset.rds")
# Lasso model
lasso_model <- call_models(df, 'Lasso', get_lasso, "y")
# Elastic net model
enet_model <- call_models(df, 'Enet', get_elasticnet, "y")
warnings()
call_models = function(data, model_name, model_function, variable, type = "default"){
#' Chamadas para Modelos de Previsão
#'
#' Esta função aplica um modelo de previsão a um conjunto de dados, utilizando uma janela deslizante para gerar previsões.
#'
#' @param data Um `data.frame` ou matriz contendo os dados a serem modelados.
#' @param model_name O nome do modelo a ser utilizado (apenas um rótulo).
#' @param model_function A função que implementa o modelo de previsão a ser aplicado.
#' @param variable O nome da variável dependente que será prevista.
#' @param type O tipo de dados. O padrão é "default".
#' @return Uma lista contendo os seguintes elementos:
#' - mae: O erro absoluto médio das previsões.
#' - rmse: A raiz do erro quadrático médio das previsões.
#' - forecasts: As previsões geradas pelo modelo para o horizonte definido.
#'
#' @examples
#' df <- data.frame(time = 1:100, variable = rnorm(100))
#' results <- call_models(data = df, model_name = "MyModel", model_function = my_model_function, variable = "variable")
#'
#' @export
data = as.matrix(data)
model_name <- model_name
model_function <- model_function
nwindows = nrow(data)*0.25
y_out <- tail(data[, variable], nwindows)
#y_out <- tail(data[, "BZEAMOM"], nwindows)
#if (type == 'tb'){
#  data <- as.data.frame(data) %>%
#    select(-c(1)) %>%
#    as.matrix()
#}
model_list <- list()
for_ind <- c(1, 2, 3, 4, 5, 6, 9, 12)
#for_ind = c(1)
for (i in for_ind) {
model <- rolling_window(
fn = model_function,
df = data,
nwindow = nwindows + i - 1,
horizon = i,
variable = variable,
n_lags = 4
)
model_list[[i]] <- model
cat(i, "\n")
}
forecasts <- Reduce(
f = cbind,
x = lapply(model_list, function(x) head(x$forecast, nwindows))
) %>% as.matrix()
plot.ts(y_out)
lines(forecasts[, 1], col = 2)
rmse <- apply(forecasts, 2, f_rmse, y = y_out) %>% print()
mae = apply(forecasts, 2, f_mae, y = y_out) %>% print()
results = list(mae = mae, rmse = rmse, forecasts = forecasts)
return(results)
}
get_boosting <- function(ind, df, variable, horizon, n_lags) {
#' Ajuste de Modelo de Boosting
#'
#' Esta função ajusta um modelo de boosting aos dados fornecidos e gera previsões.
#'
#' @param ind Índices das observações a serem utilizadas.
#' @param df Um data.frame contendo os dados.
#' @param variable Nome da variável dependente a ser modelada.
#' @param horizon Horizonte de previsão.
#' @param n_lags Número de defasagens a serem usadas na modelagem.
#' @return Uma lista contendo as previsões do modelo de boosting e informações sobre o modelo ajustado.
#'
#' @examples
#' results <- get_boosting(ind = 1:100, df = my_data, variable = "sales", horizon = 10, n_lags = 4)
library(mboost)
library(forecast)
# INICIALIZACAO DE VARIAVEIS
set.seed(100)
data_in <- dataprep(
type = 'default',
#type = 'tb',
ind = ind,
df = df,
variable = variable,
horizon = horizon,
n_lags = n_lags
)
y_in <- data_in$y_in
x_in <- data_in$x_in
x_out <- data_in$x_out
# AJUSTE DO MODELO DE BOOSTING
reg_full <- glmboost(
y = y_in,
x = as.matrix(x_in),
offset = 0, # mean(y_in),
center = TRUE,
control = boost_control(mstop = 300, nu = 0.1)
)
# DETERMINACAO DO NUMERO OTIMO DE ITERACOES
cv5f <- cv(model.weights(reg_full), type = "kfold", B = 5)
cv_seq <- cvrisk(reg_full, folds = cv5f, papply = lapply)
m_opt <- mstop(cv_seq)
# AJUSTE DO MODELO COM O NUMERO OTIMO DE ITERACOES
reg_opt <- reg_full[m_opt]
# PREVISAO PARA A JANELA DE TESTE
opt_boosting <- predict(
object = reg_opt,
newdata = matrix(x_out, nrow = 1)
) %>% as.vector() + mean(y_in)
# RESULTADOS
results <- list(
forecast = opt_boosting,
outputs = list(
m_opt = m_opt,
reg_opt = reg_opt
)
)
return(results)
}
rolling_window <- function(fn, df, nwindow = 1, horizon, variable, ...) {
#' Janela Movel para Modelagem
#'
#' Esta função aplica uma função especificada a uma janela deslizante de dados em um `data.frame` para realizar previsões.
#'
#' @param fn A função a ser aplicada em cada janela deslizante. Esta função deve retornar um objeto com as previsões e saídas.
#' @param df Um `data.frame` contendo os dados a serem processados.
#' @param nwindow O tamanho da janela deslizante. O padrão é 1.
#' @param horizon O horizonte de previsão, que determina quantas observações devem ser projetadas para frente.
#' @param variable O nome da variável dependente a ser utilizada na análise.
#' @param ... Argumentos adicionais a serem passados para a função `fn`.
#' @return Uma lista com dois elementos:
#' - forecast: Um vetor com as previsões resultantes de cada aplicação da função nas janelas deslizantes.
#' - outputs: Uma lista contendo as saídas resultantes de cada aplicação da função nas janelas deslizantes.
#'
#' @examples
#' df <- data.frame(data = 1:100, variable = rnorm(100))
#' result <- rolling_window(fn = my_forecast_function, df = df, nwindow = 5, horizon = 1, variable = 'variable')
#'
#' @export
#ind <- seq_len(nrow(df))
window_size <- nrow(df) - nwindow
indmat <- matrix(NA, window_size, nwindow)
indmat[1, ] <- seq_len(ncol(indmat))
for (i in 2:nrow(indmat)) {
indmat[i, ] <- indmat[i - 1, ] + 1
}
rw <- apply(
X = indmat,
MARGIN = 2,
FUN = fn,
df = df,
horizon = horizon,
variable = variable,
...
)
forecast <- unlist(lapply(rw, function(x) x$forecast))
outputs <- lapply(rw, function(x) x$outputs)
return(list(forecast = forecast, outputs = outputs))
}
dataprep <- function(type = '...', ind, df, variable, horizon, n_lags = 4) {
#' Preparação de Dados para Modelagem
#'
#' Esta função prepara os dados para análise, criando variáveis de defasagem e separando as variáveis dependentes e independentes.
#'
#' @param type Um caractere que define o tipo de preparação de dados. Pode ser 'tb' para uma estrutura de tabela ou outro valor conforme necessário.
#' @param ind Um vetor de índices para selecionar as linhas do `data.frame`.
#' @param df Um `data.frame` contendo os dados a serem preparados.
#' @param variable O nome da variável dependente a ser utilizada na análise.
#' @param horizon O horizonte de previsão, que determina quantas observações devem ser projetadas para frente.
#' @param n_lags O número de defasagens a serem criadas. Deve ser um inteiro maior que 1. O padrão é 4.
#' @return Uma lista com três elementos:
#' - x_in: Um `data.frame` contendo as variáveis independentes de entrada, excluindo os últimos `horizon` registros.
#' - x_out: Um vetor contendo a última observação das variáveis independentes (a previsão).
#' - y_in: Um vetor com os valores correspondentes da variável dependente para as observações de entrada.
#'
#' @examples
#' df <- data.frame(data = 1:100, variable = rnorm(100))
#' result <- dataprep(type = 'tb', ind = 1:80, df = df, variable = 'variable', horizon = 1, n_lags = 4)
#'
#' @export
if (n_lags <= 1) {
stop("n_lags deve ser um inteiro maior do que 1.")
}
df <- df[ind, ]
y <- df[, variable]
if (type == 'tb'){
x_aux = df[,-1]
} else{
x_aux = df
}
x <- embed(as.matrix(x_aux), n_lags)
names_x <- NULL
for (i in seq_len(n_lags)) {
names_x <- c(
names_x,
paste(colnames(x_aux), "_lag_", horizon + i - 1, sep = "")
)
}
colnames(x) <- names_x
x_in <- x[-c((nrow(x) - horizon + 1):nrow(x)), ]
x_out <- x[nrow(x), ]
x_out <- t(as.vector(x_out))
y_in <- tail(y, nrow(x_in))
return(list(x_in = x_in, x_out = x_out, y_in = y_in))
}
source("~/GitHub/gdp-forecasting-with-ML/04_get_Data_Prep.R", echo=TRUE)
source("~/GitHub/gdp-forecasting-with-ML/test_df.R", echo=TRUE)
datest = df$date
df[] <- lapply(df, as.numeric)
df$date <- NULL
message("Mean")
# Mean model
mean_model <- call_models(df, 'Mean', get_mean, "y")
warnings()
call_models = function(data, model_name, model_function, variable, type = "default"){
#' Chamadas para Modelos de Previsão
#'
#' Esta função aplica um modelo de previsão a um conjunto de dados, utilizando uma janela deslizante para gerar previsões.
#'
#' @param data Um `data.frame` ou matriz contendo os dados a serem modelados.
#' @param model_name O nome do modelo a ser utilizado (apenas um rótulo).
#' @param model_function A função que implementa o modelo de previsão a ser aplicado.
#' @param variable O nome da variável dependente que será prevista.
#' @param type O tipo de dados. O padrão é "default".
#' @return Uma lista contendo os seguintes elementos:
#' - mae: O erro absoluto médio das previsões.
#' - rmse: A raiz do erro quadrático médio das previsões.
#' - forecasts: As previsões geradas pelo modelo para o horizonte definido.
#'
#' @examples
#' df <- data.frame(time = 1:100, variable = rnorm(100))
#' results <- call_models(data = df, model_name = "MyModel", model_function = my_model_function, variable = "variable")
#'
#' @export
data = as.matrix(data)
model_name <- model_name
model_function <- model_function
nwindows = nrow(data)*0.3
y_out <- tail(data[, variable], nwindows)
#if (type == 'tb'){
#  data <- as.data.frame(data) %>%
#    select(-c(1)) %>%
#    as.matrix()
#}
model_list <- list()
for_ind <- c(1, 4)
for (i in for_ind) {
model <- rolling_window(
fn = model_function,
df = data,
nwindow = nwindows + i - 1,
horizon = i,
variable = variable,
n_lags = 4
)
model_list[[i]] <- model
cat(i, "\n")
}
forecasts <- Reduce(
f = cbind,
x = lapply(model_list, function(x) head(x$forecast, nwindows))
) %>% as.matrix()
plot.ts(y_out)
lines(forecasts[, 1], col = 2)
rmse <- apply(forecasts, 2, f_rmse, y = y_out) %>% print()
mae = apply(forecasts, 2, f_mae, y = y_out) %>% print()
results = list(mae = mae, rmse = rmse, forecasts = forecasts)
return(results)
}
saveRDS(df, "df_test.rds")
df <- readRDS("df_test.rds")
