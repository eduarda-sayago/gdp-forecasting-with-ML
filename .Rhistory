#' Esta função calcula o Cumulative Squared Forecast Error (CSFE) para diferentes horizontes de previsão
#' a partir das previsões de um modelo e de um benchmark.
#'
#' @param model Um objeto contendo as previsões do modelo, com colunas representando diferentes horizontes.
#' @param benchmark Um objeto contendo as previsões do benchmark, com colunas correspondendo aos mesmos horizontes.
#' @param y_real Um vetor numérico contendo os valores reais observados.
#' @return Uma matriz com os erros quadráticos acumulados para cada horizonte de previsão.
#'
#' @examples
#' csfe_results <- csfe(model, benchmark, y_real)
#' print(csfe_results)
#'
h1 = f_csfe(model$forecast[,1], benchmarkq$forecasts[,1], y_real = y_real)
h4 = f_csfe(model$forecast[,2], benchmarkq$forecasts[,2], y_real = y_real)
cbind(h1, h4)
}
yq <- datasetq$`pib_rs`[65:92] #revise
dm_tests <- compute_dm(model_names = c("LASSO", "Elastic Net", "Random Forest"),
model_dataframes = list(lasso_modelq, enet_modelq, rf_modelq),
horizons = c(1, 4),
orig_data = yq)
# ================================================
# ------Performance evaluation through CSFE-------
# ================================================
qcsfe_lasso = csfe1(lasso_modelq, benchmarkq, yq)
qcsfe_enet = csfe1(enet_modelq, benchmarkq, yq)
qcsfe_rf = csfe1(rf_modelq, benchmarkp, yq)
f_csfe <- function(x, y_bench, y_real) {
#' Calcula o Cumulative Squared Forecast Error (CSFE)
#'
#' Esta função calcula o erro quadrático acumulado da previsão em relação a um benchmark e
#' os valores reais. O resultado permite avaliar a precisão do modelo em comparação com o benchmark.
#'
#' @param x Um vetor numérico contendo as previsões do modelo.
#' @param y_bench Um vetor numérico contendo as previsões do benchmark.
#' @param y_real Um vetor numérico contendo os valores reais observados.
#' @return Um vetor numérico que contém o erro quadrático acumulado para cada ponto no tempo.
#'
#' @examples
#' f_csfe(c(1, 2, 3), c(1.5, 2.5, 3.5), c(1, 2, 3)) # Retorna o erro quadrático acumulado
#'
error_bench <- (y_bench - y_real)^2
error_x <- (x - y_real)^2
result <- cumsum(error_bench - error_x)
return(result)
}
csfe = function(model, benchmarkq, y_real){
#' Calcula CSFE para Diferentes Horizontes
#'
#' Esta função calcula o Cumulative Squared Forecast Error (CSFE) para diferentes horizontes de previsão
#' a partir das previsões de um modelo e de um benchmark.
#'
#' @param model Um objeto contendo as previsões do modelo, com colunas representando diferentes horizontes.
#' @param benchmark Um objeto contendo as previsões do benchmark, com colunas correspondendo aos mesmos horizontes.
#' @param y_real Um vetor numérico contendo os valores reais observados.
#' @return Uma matriz com os erros quadráticos acumulados para cada horizonte de previsão.
#'
#' @examples
#' csfe_results <- csfe(model, benchmark, y_real)
#' print(csfe_results)
#'
h1 = f_csfe(model$forecast[,1], benchmarkq$forecasts[,1], y_real = y_real)
h4 = f_csfe(model$forecast[,2], benchmarkq$forecasts[,2], y_real = y_real)
cbind(h1, h4)
}
yq <- datasetq$`pib_rs`[65:92] #revise
dm_tests <- compute_dm(model_names = c("LASSO", "Elastic Net", "Random Forest"),
model_dataframes = list(lasso_modelq, enet_modelq, rf_modelq),
horizons = c(1, 4),
orig_data = yq)
# ================================================
# ------Performance evaluation through CSFE-------
# ================================================
qcsfe_lasso = csfe1(lasso_modelq, benchmarkq, yq)
qcsfe_enet = csfe1(enet_modelq, benchmarkq, yq)
qcsfe_rf = csfe1(rf_modelq, benchmarkp, yq)
add_stars <- function(pvalues, alpha_levels = c(0.05, 0.01, 0.001)) {
#' Adiciona Estrelas para Indicar Níveis de Significância
#'
#' Esta função atribui estrelas (*) aos valores-p com base em níveis de significância especificados.
#'
#' @param pvalues Um vetor de valores-p.
#' @param alpha_levels Um vetor de níveis de significância (padrão: 0.05, 0.01, 0.001).
#'
#' @return Um vetor de caracteres com estrelas correspondentes aos valores-p.
#'
#' @examples
#' stars <- add_stars(c(0.02, 0.001, 0.07))
#'
stars <- character(length(pvalues))
for (i in seq_along(alpha_levels)) {
stars[pvalues <= alpha_levels[i]] <- paste(rep("*", i), collapse = "")
}
return(stars)
}
#QUARTERLY
compute_dm = function(model_names, model_dataframes, horizons, orig_data){
#' Computa o Teste de Diebold-Mariano para Modelos de Previsão
#'
#' Esta função calcula o teste de Diebold-Mariano para diferentes modelos de previsão e horizontes de previsão.
#'
#' @return Uma lista contendo matrizes de valores-p formatadas com estrelas para três conjuntos de modelos:
#'   - pvalues_tb: valores-p para modelos baseados em texto.
#'   - pvalues_eco: valores-p para modelos econômicos.
#'   - pvalues_eco_tb: valores-p para modelos que combinam dados econômicos e baseados em texto.
#'
#' @examples
#' dm_results <- compute_dm()
pvalues <- matrix(nrow = length(model_names), ncol = length(horizons))
results <- list()
results_tb = results
pvalues_tb = pvalues
for (m in seq_along(model_names)) {
model_name <- model_names[m]
model_df <- model_dataframes[[m]]
for (i in seq_along(horizons)) {
h <- horizons[i]
x <- data.frame(benchmarkq$forecasts)[[i]] #the only thing that changes from quart to month
y <- data.frame(model_df$forecasts)[[i]]
#residual = y - ŷ
dm = dm.test(
e1 = orig_data - y,
e2 = orig_data - x,
h = h,
alternative = 'two.sided',
varestimator = 'bartlett'
)
pvalues[m, i] <- dm$p.value
results[[paste0(model_name, '- horizon ', h)]] <- dm
}
}
rownames(pvalues) <- model_names
colnames(pvalues) <- horizons
pvalues_eco_stars <- add_stars(pvalues)
pvalues <- matrix(paste0(format(pvalues, nsmall = 10), pvalues_eco_stars), nrow = nrow(pvalues), dimnames = dimnames(pvalues))
pvalues
list = list(
pvalues = pvalues)
return(list)
}
#MONTHLY
compute_dm1 = function(model_names, model_dataframes, horizons, orig_data){
#' Computa o Teste de Diebold-Mariano para Modelos de Previsão
#'
#' Esta função calcula o teste de Diebold-Mariano para diferentes modelos de previsão e horizontes de previsão.
#'
#' @return Uma lista contendo matrizes de valores-p formatadas com estrelas para três conjuntos de modelos:
#'   - pvalues_tb: valores-p para modelos baseados em texto.
#'   - pvalues_eco: valores-p para modelos econômicos.
#'   - pvalues_eco_tb: valores-p para modelos que combinam dados econômicos e baseados em texto.
#'
#' @examples
#' dm_results <- compute_dm()
pvalues <- matrix(nrow = length(model_names), ncol = length(horizons))
results <- list()
results_tb = results
pvalues_tb = pvalues
for (m in seq_along(model_names)) {
model_name <- model_names[m]
model_df <- model_dataframes[[m]]
for (i in seq_along(horizons)) {
h <- horizons[i]
x <- data.frame(benchmark$forecasts)[[i]] #the only thing that changes from quart to month
y <- data.frame(model_df$forecasts)[[i]]
#residual = y - ŷ
dm = dm.test(
e1 = orig_data - y,
e2 = orig_data - x,
h = h,
alternative = 'two.sided',
varestimator = 'bartlett'
)
pvalues[m, i] <- dm$p.value
results[[paste0(model_name, '- horizon ', h)]] <- dm
}
}
rownames(pvalues) <- model_names
colnames(pvalues) <- horizons
pvalues_eco_stars <- add_stars(pvalues)
pvalues <- matrix(paste0(format(pvalues, nsmall = 10), pvalues_eco_stars), nrow = nrow(pvalues), dimnames = dimnames(pvalues))
pvalues
list = list(
pvalues = pvalues)
return(list)
}
yq <- datasetq$`pib_rs`[65:92] #revise
dm_tests <- compute_dm(model_names = c("LASSO", "Elastic Net", "Random Forest"),
model_dataframes = list(lasso_modelq, enet_modelq, rf_modelq),
horizons = c(1, 4),
orig_data = yq)
# ================================================
# ------Performance evaluation through CSFE-------
# ================================================
qcsfe_lasso = csfe1(lasso_modelq, benchmarkq, yq)
qcsfe_enet = csfe1(enet_modelq, benchmarkq, yq)
qcsfe_rf = csfe1(rf_modelq, benchmarkp, yq)
qcsfe_lasso = csfe(lasso_modelq, benchmarkq, yq)
qcsfe_enet = csfe(enet_modelq, benchmarkq, yq)
qcsfe_rf = csfe(rf_modelq, benchmarkp, yq)
qcsfe_rf = csfe(rf_modelq, benchmarkq, yq)
qcsfe_lasso <- as.data.frame(qcsfe_lasso)
qcsfe_enet <- as.data.frame(qcsfe_enet)
qcsfe_rf <- as.data.frame(qcsfe_rf)
# ================================================
# --------------------Graphs----------------------
# ================================================
y_ax <- date[65:92]
View(benchmarkq)
csfe_q <- data.frame(date = y_ax,
lasso_h1 = qcsfe_lasso$h1,
lasso_h12 = qcsfe_lasso$h4,
enet_h1 = qcsfe_enet$h1,
enet_h12 = qcsfe_enet$h4,
rf_h1 = qcsfe_rf$h1,
rf_h12 = qcsfe_rf$h4)
View(get_stationarity)
# ================================================
# -----------------1st try - logmresults ----------- old log fun
# ================================================
# logm = old log
# logw = new log
# add all dummies excpt dflood cause fuck that sht
rawm_ibc_log <- get_logs(rawm_ibc)
logm_results <- do.call(cbind, rawm_ibc_log$results) %>% as.data.frame()
logm_results$date <- as.Date(logm_results$date, origin = "1970-01-01")
dummies <- data.frame(matrix(ncol = 0, nrow = nrow(logm_results)))
dummies$month <- lubridate::month(logm_results$date)
logm_results$M2 <- ifelse(dummies$month == 2, 1, 0)
logm_results$M3 <- ifelse(dummies$month == 3, 1, 0)
logm_results$M4 <- ifelse(dummies$month == 4, 1, 0)
logm_results$M5 <- ifelse(dummies$month == 5, 1, 0)
logm_results$M6 <- ifelse(dummies$month == 6, 1, 0)
logm_results$M7 <- ifelse(dummies$month == 7, 1, 0)
logm_results$M8 <- ifelse(dummies$month == 8, 1, 0)
logm_results$M9 <- ifelse(dummies$month == 9, 1, 0)
logm_results$M10 <- ifelse(dummies$month == 10, 1, 0)
logm_results$M11 <- ifelse(dummies$month == 11, 1, 0)
logm_results$M12 <- ifelse(dummies$month == 12, 1, 0)
logm_results$d_pandemic <- ifelse(logm_results$date >= as.Date("2020-01-01") &
logm_results$date <= as.Date("2020-10-01"), 1, 0)
logm_results$d_shift <- ifelse(logm_results$date < as.Date("2013-01-01"),
seq_len(sum(logm_results$date < as.Date("2013-01-01"))),0)
datelm = logm_results$date
logm_results$date <- NULL
logm_results[] <- lapply(logm_results, as.numeric)
benchmark1w <- call_models1(logm_results, 'Logmold - SARIMA', get_sarima, "ibc_rs")
# h=1  RMSE: ; MAE:    ; MAPE:
# h=12 RMSE: ; MAE:    ; MAPE:
lasso_model1w <- call_models1(logm_results, 'Logmold - LASSO', get_lasso, "ibc_rs")
# h=1  RMSE: ; MAE:    ; MAPE:
# h=12 RMSE: ; MAE:    ; MAPE:
enet_model1w <- call_models1(logm_results, 'Logmold - Elastic Net', get_elasticnet, "ibc_rs")
# h=1  RMSE: ; MAE:    ; MAPE:
# h=12 RMSE: ; MAE:    ; MAPE:
#rf_modelw <- call_models1(logm_results, 'Random Forest - IBC-w', get_rf, "ibc_rs")
# h=1  RMSE: ; MAE:    ; MAPE:
# h=12 RMSE: ; MAE:    ; MAPE:
# ================================================
# -----------------2nd try - logwresults ----------- new log fun
# ================================================
raww_ibc_log <- get_logs1(rawm_ibc)
logw_results <- do.call(cbind, raww_ibc_log$results) %>% as.data.frame()
logw_results$date <- as.Date(logw_results$date, origin = "1970-01-01")
dummies <- data.frame(matrix(ncol = 0, nrow = nrow(logw_results)))
dummies$month <- lubridate::month(logw_results$date)
logw_results$M2 <- ifelse(dummies$month == 2, 1, 0)
logw_results$M3 <- ifelse(dummies$month == 3, 1, 0)
logw_results$M4 <- ifelse(dummies$month == 4, 1, 0)
logw_results$M5 <- ifelse(dummies$month == 5, 1, 0)
logw_results$M6 <- ifelse(dummies$month == 6, 1, 0)
logw_results$M7 <- ifelse(dummies$month == 7, 1, 0)
logw_results$M8 <- ifelse(dummies$month == 8, 1, 0)
logw_results$M9 <- ifelse(dummies$month == 9, 1, 0)
logw_results$M10 <- ifelse(dummies$month == 10, 1, 0)
logw_results$M11 <- ifelse(dummies$month == 11, 1, 0)
logw_results$M12 <- ifelse(dummies$month == 12, 1, 0)
logw_results$d_pandemic <- ifelse(logw_results$date >= as.Date("2020-01-01") &
logw_results$date <= as.Date("2020-10-01"), 1, 0)
#logw_results$d_rsflood <- ifelse(logw_results$date == as.Date("2024-06-01"), 1, 0)
logw_results$d_shift <- ifelse(logw_results$date < as.Date("2013-01-01"),
seq_len(sum(logw_results$date < as.Date("2013-01-01"))),0)
datelw = logw_results$date
logw_results$date <- NULL
logw_results[] <- lapply(logw_results, as.numeric)
benchmark2w <- call_models1(logw_results, 'Logwnew - SARIMA', get_sarima, "ibc_rs")
# h=1  RMSE: ; MAE:    ; MAPE:
# h=12 RMSE: ; MAE:    ; MAPE:
lasso_model2w <- call_models1(logw_results, 'Logwnew - LASSO', get_lasso, "ibc_rs")
# h=1  RMSE: ; MAE:    ; MAPE:
# h=12 RMSE: ; MAE:    ; MAPE:
enet_model2w <- call_models1(logw_results, 'Logwnew - Elastic Net', get_elasticnet, "ibc_rs")
# h=1  RMSE: ; MAE:    ; MAPE:
# h=12 RMSE: ; MAE:    ; MAPE:
#rf_modelw <- call_models1(logw_results, 'Random Forest - IBC-w', get_rf, "ibc_rs")
# h=1  RMSE: ; MAE:    ; MAPE:
# h=12 RMSE: ; MAE:    ; MAPE:
# ================================================
# -----------------3rd try - rawm_ibc ----------- no log, raw data
# ================================================
rawm_ibc$date <- as.Date(rawm_ibc$date, origin = "1970-01-01")
dummies <- data.frame(matrix(ncol = 0, nrow = nrow(rawm_ibc)))
dummies$month <- lubridate::month(rawm_ibc$date)
rawm_ibc$M2 <- ifelse(dummies$month == 2, 1, 0)
rawm_ibc$M3 <- ifelse(dummies$month == 3, 1, 0)
rawm_ibc$M4 <- ifelse(dummies$month == 4, 1, 0)
rawm_ibc$M5 <- ifelse(dummies$month == 5, 1, 0)
rawm_ibc$M6 <- ifelse(dummies$month == 6, 1, 0)
rawm_ibc$M7 <- ifelse(dummies$month == 7, 1, 0)
rawm_ibc$M8 <- ifelse(dummies$month == 8, 1, 0)
rawm_ibc$M9 <- ifelse(dummies$month == 9, 1, 0)
rawm_ibc$M10 <- ifelse(dummies$month == 10, 1, 0)
rawm_ibc$M11 <- ifelse(dummies$month == 11, 1, 0)
rawm_ibc$M12 <- ifelse(dummies$month == 12, 1, 0)
rawm_ibc$d_pandemic <- ifelse(rawm_ibc$date >= as.Date("2020-01-01") &
rawm_ibc$date <= as.Date("2020-10-01"), 1, 0)
#rawm_ibc$d_rsflood <- ifelse(rawm_ibc$date == as.Date("2024-06-01"), 1, 0)
rawm_ibc$d_shift <- ifelse(rawm_ibc$date < as.Date("2013-01-01"),
seq_len(sum(rawm_ibc$date < as.Date("2013-01-01"))),0)
daterm = rawm_ibc$date
rawm_ibc$date <- NULL
rawm_ibc[] <- lapply(rawm_ibc, as.numeric)
benchmark3w <- call_models1(rawm_ibc, 'Rawdata - SARIMA', get_sarima, "ibc_rs")
# h=1  RMSE: ; MAE:    ; MAPE:
# h=12 RMSE: ; MAE:    ; MAPE:
lasso_model3w <- call_models1(rawm_ibc, 'Rawdata - LASSO', get_lasso, "ibc_rs")
# h=1  RMSE: ; MAE:    ; MAPE:
# h=12 RMSE: ; MAE:    ; MAPE:
enet_model3w <- call_models1(rawm_ibc, 'Rawdata - Elastic Net', get_elasticnet, "ibc_rs")
# h=1  RMSE: ; MAE:    ; MAPE:
# h=12 RMSE: ; MAE:    ; MAPE:
#rf_modelw <- call_models1(rawm_ibc, 'Random Forest - IBC-w', get_rf, "ibc_rs")
# h=1  RMSE: ; MAE:    ; MAPE:
# h=12 RMSE: ; MAE:    ; MAPE:
# ================================================
# -----------------4th try - rawm_stry --------- no log fun, but adf test
# ================================================
rawm_ibc <- readRDS("rawM_ibc.rds")
rawm_stry <- get_stationarity(rawm_ibc, type_df = type_dfm)
type_dfm <- rawm_stry$type_df
rawm_stry <- as.data.frame(rawm_stry$df)
rawm_stry$date <- as.Date(rawm_stry$date, origin = "1970-01-01")
dummies <- data.frame(matrix(ncol = 0, nrow = nrow(rawm_stry)))
dummies$month <- lubridate::month(rawm_stry$date)
rawm_stry$M2 <- ifelse(dummies$month == 2, 1, 0)
rawm_stry$M3 <- ifelse(dummies$month == 3, 1, 0)
rawm_stry$M4 <- ifelse(dummies$month == 4, 1, 0)
rawm_stry$M5 <- ifelse(dummies$month == 5, 1, 0)
rawm_stry$M6 <- ifelse(dummies$month == 6, 1, 0)
rawm_stry$M7 <- ifelse(dummies$month == 7, 1, 0)
rawm_stry$M8 <- ifelse(dummies$month == 8, 1, 0)
rawm_stry$M9 <- ifelse(dummies$month == 9, 1, 0)
rawm_stry$M10 <- ifelse(dummies$month == 10, 1, 0)
rawm_stry$M11 <- ifelse(dummies$month == 11, 1, 0)
rawm_stry$M12 <- ifelse(dummies$month == 12, 1, 0)
rawm_stry$d_pandemic <- ifelse(rawm_stry$date >= as.Date("2020-01-01") &
rawm_stry$date <= as.Date("2020-10-01"), 1, 0)
rawm_stry$d_shift <- ifelse(rawm_stry$date < as.Date("2013-01-01"),
seq_len(sum(rawm_stry$date < as.Date("2013-01-01"))),0)
datest = rawm_stry$date
rawm_stry$date <- NULL
rawm_stry[] <- lapply(rawm_stry, as.numeric)
benchmark4w <- call_models1(rawm_stry, 'Nlogadf - SARIMA', get_sarima, "ibc_rs")
# h=1  RMSE: ; MAE:    ; MAPE:
# h=12 RMSE: ; MAE:    ; MAPE:
lasso_model4w <- call_models1(rawm_stry, 'Nlogadf - LASSO', get_lasso, "ibc_rs")
# h=1  RMSE: ; MAE:    ; MAPE:
# h=12 RMSE: ; MAE:    ; MAPE:
enet_model4w <- call_models1(rawm_stry, 'Nlogadf - Elastic Net', get_elasticnet, "ibc_rs")
# h=1  RMSE: ; MAE:    ; MAPE:
# h=12 RMSE: ; MAE:    ; MAPE:
View(benchmark1w)
benchmark1w[["rmse"]]
benchmark1w[["mae"]]
benchmark1w[["mape"]]
View(benchmark2w)
benchmark2w[["rmse"]]
benchmark2w[["mae"]]
benchmark2w[["mape"]]
View(benchmark2w)
benchmark2w[["rmse"]]
benchmark2w[["mae"]]
benchmark2w[["mape"]]
View(benchmark3w)
benchmark2w[["rmse"]]
benchmark2w[["mape"]]
benchmark3w[["rmse"]]
benchmark3w[["mae"]]
benchmark3w[["mape"]]
View(benchmark4w)
benchmark4w[["rmse"]]
benchmark4w[["mae"]]
benchmark4w[["mape"]]
View(benchmark)
benchmark[["rmse"]]
benchmark[["mae"]]
benchmark[["mape"]]
View(lasso_model)
lasso_model[["rmse"]]
lasso_model[["mae"]]
lasso_model[["mape"]]
View(lasso_model1w)
lasso_model1w[["rmse"]]
lasso_model1w[["mae"]]
lasso_model1w[["mape"]]
View(lasso_model2w)
lasso_model2w[["rmse"]]
lasso_model2w[["mae"]]
lasso_model2w[["mape"]]
View(lasso_model3w)
lasso_model3w[["rmse"]]
lasso_model3w[["mae"]]
lasso_model3w[["mape"]]
View(lasso_model4w)
lasso_model4w[["rmse"]]
lasso_model4w[["mae"]]
lasso_model4w[["mape"]]
View(enet_model)
enet_model[["rmse"]]
enet_model[["mae"]]
enet_model[["mape"]]
View(enet_model1w)
enet_model1w[["rmse"]]
enet_model1w[["mae"]]
enet_model1w[["mape"]]
View(enet_model2w)
enet_model2w[["rmse"]]
enet_model2w[["mae"]]
enet_model2w[["mape"]]
View(enet_model3w)
enet_model3w[["rmse"]]
enet_model3w[["mae"]]
enet_model3w[["mape"]]
View(enet_model4w)
enet_model4w[["rmse"]]
enet_model4w[["mae"]]
enet_model4w[["mape"]]
View(rf_model)
rf_model[["rmse"]]
rf_model[["mae"]]
rf_model[["mape"]]
rf_modelw <- call_models1(logm_results, 'Logmold Random Forest - IBC-w', get_rf, "ibc_rs")
rf_model1w <- call_models1(logm_results, 'Logmold Random Forest - IBC-w', get_rf, "ibc_rs")
library(dplyr)
library(lubridate)
rf_model1w <- call_models1(logm_results, 'Logmold Random Forest - IBC-w', get_rf, "ibc_rs")
get_rf <- function(ind, df, variable, horizon, n_lags) {
#' Ajuste de Modelo de Random Forest
#'
#' Esta função ajusta um modelo de Random Forest aos dados fornecidos e gera previsões.
#'
#' @param ind Índices das observações a serem utilizadas.
#' @param df Um data.frame contendo os dados.
#' @param variable Nome da variável dependente a ser modelada.
#' @param horizon Horizonte de previsão.
#' @param n_lags Número de defasagens a serem usadas na modelagem.
#' @return Uma lista contendo as previsões do modelo de Random Forest e informações sobre o modelo ajustado.
#'
#' @examples
#' results <- get_rf(ind = 1:100, df = my_data, variable = "sales", horizon = 10, n_lags = 4)
library(dplyr)
library(caret)
library(randomForest)
# Preparação dos dados (mesmo estilo do boosting)
data_in <- dataprep(
type = 'default',
ind = ind,
df = df,
variable = variable,
horizon = horizon,
n_lags = n_lags
)
y_in <- as.numeric(data_in$y_in)
x_in <- as.data.frame(data_in$x_in)
x_out <- as.data.frame(data_in$x_out)
# Ensure x_out has the same column names as x_in
if (ncol(x_out) == ncol(x_in)) {
colnames(x_out) <- colnames(x_in)
} else {
x_out <- as.data.frame(t(x_out))
colnames(x_out) <- colnames(x_in)
}
# CV setup
set.seed(100)
ctrl <- trainControl(method = "cv", number = 5)
p <- ncol(x_in)
grid <- expand.grid(
mtry = unique(pmax(1, c(1L, floor(sqrt(p)), floor(p/3), floor(p/2), p)))
)
# Ajuste do modelo com CV
rf_cv <- train(
x = x_in,
y = y_in,
method = "rf",
trControl = ctrl,
tuneGrid = grid,
ntree = 500,
metric = "RMSE"
)
print(rf_cv$bestTune)
# Previsão
rf_forecast <- predict(rf_cv, newdata = x_out)
# Saída
results <- list(
forecast = as.numeric(rf_forecast),
outputs = list(
rf_cv = rf_cv,
best_mtry = rf_cv$bestTune$mtry
)
)
return(results)
}
View(raw_gdp)
