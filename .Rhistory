)
model_list[[i]] <- model
cat(i, "\n")
}
forecasts <- Reduce(
f = cbind,
x = lapply(model_list, function(x) head(x$forecast, nwindows))
) %>% as.matrix()
for (i in for_ind) {
filename <- paste0("forecast ",model_name,"-horizon-" , i, ".png")
filepath <- file.path("Plots", filename)
png(filepath, width = 1000, height = 600)
col_idx <- match(i, for_ind)  # find which column corresponds to horizon i
plot.ts(y_out,
main = paste0("Forecast with ", model_name, " (horizon = ", i, ")"),
lwd = 2)
lines(forecasts[, col_idx], col = 2, lwd = 2)
dev.off()
}
rmse <- apply(forecasts, 2, f_rmse, y = y_out) %>% print()
mae = apply(forecasts, 2, f_mae, y = y_out) %>% print()
results = list(mae = mae, rmse = rmse, forecasts = forecasts)
return(results)
}
lasso_model <- call_models(dataset, 'LASSO', get_lasso, "pib_rs")
call_models = function(data, model_name, model_function, variable, type = "default"){
#' Chamadas para Modelos de Previsão
#'
#' Esta função aplica um modelo de previsão a um conjunto de dados, utilizando uma janela deslizante para gerar previsões.
#'
#' @param data Um `data.frame` ou matriz contendo os dados a serem modelados.
#' @param model_name O nome do modelo a ser utilizado (apenas um rótulo).
#' @param model_function A função que implementa o modelo de previsão a ser aplicado.
#' @param variable O nome da variável dependente que será prevista.
#' @param type O tipo de dados. O padrão é "default".
#' @return Uma lista contendo os seguintes elementos:
#' - mae: O erro absoluto médio das previsões.
#' - rmse: A raiz do erro quadrático médio das previsões.
#' - forecasts: As previsões geradas pelo modelo para o horizonte definido.
#'
#' @examples
#' df <- data.frame(time = 1:100, variable = rnorm(100))
#' results <- call_models(data = df, model_name = "MyModel", model_function = my_model_function, variable = "variable")
#'
#' @export
data = as.matrix(data)
model_name <- model_name
model_function <- model_function
n <- nrow(data)
b = round(n*0.3) # base
y_out <- tail(data[, variable], b)
model_list <- list()
for_ind <- c(1, 4)
for (i in for_ind) {
model <- rolling_window2(
fn = model_function,
df = data,
nwindow = n - b + 1,
horizon = i,
variable = variable,
n_lags = 4
)
model_list[[i]] <- model
cat(i, "\n")
}
forecasts <- Reduce(
f = cbind,
x = lapply(model_list, function(x) head(x$forecast, b))
) %>% as.matrix()
for (i in for_ind) {
filename <- paste0("forecast ",model_name,"-horizon-" , i, ".png")
filepath <- file.path("Plots", filename)
png(filepath, width = 1000, height = 600)
col_idx <- match(i, for_ind)  # find which column corresponds to horizon i
plot.ts(y_out,
main = paste0("Forecast with ", model_name, " (horizon = ", i, ")"),
lwd = 2)
lines(forecasts[, col_idx], col = 2, lwd = 2)
dev.off()
}
rmse <- apply(forecasts, 2, f_rmse, y = y_out) %>% print()
mae = apply(forecasts, 2, f_mae, y = y_out) %>% print()
results = list(mae = mae, rmse = rmse, forecasts = forecasts)
return(results)
}
lasso_model <- call_models(dataset, 'LASSO', get_lasso, "pib_rs")
benchmark <- call_models(dataset, 'SARIMA', get_sarima, "pib_rs")
call_models = function(data, model_name, model_function, variable, type = "default"){
#' Chamadas para Modelos de Previsão
#'
#' Esta função aplica um modelo de previsão a um conjunto de dados, utilizando uma janela deslizante para gerar previsões.
#'
#' @param data Um `data.frame` ou matriz contendo os dados a serem modelados.
#' @param model_name O nome do modelo a ser utilizado (apenas um rótulo).
#' @param model_function A função que implementa o modelo de previsão a ser aplicado.
#' @param variable O nome da variável dependente que será prevista.
#' @param type O tipo de dados. O padrão é "default".
#' @return Uma lista contendo os seguintes elementos:
#' - mae: O erro absoluto médio das previsões.
#' - rmse: A raiz do erro quadrático médio das previsões.
#' - forecasts: As previsões geradas pelo modelo para o horizonte definido.
#'
#' @examples
#' df <- data.frame(time = 1:100, variable = rnorm(100))
#' results <- call_models(data = df, model_name = "MyModel", model_function = my_model_function, variable = "variable")
#'
#' @export
data = as.matrix(data)
model_name <- model_name
model_function <- model_function
n <- nrow(data)
b = round(n*0.3) # base
y_out <- tail(data[, variable], b)
model_list <- list()
for_ind <- c(1, 3, 6, 12)
for (i in for_ind) {
model <- rolling_window2(
fn = model_function,
df = data,
nwindow = n - b + 1,
horizon = i,
variable = variable,
n_lags = 4
)
model_list[[i]] <- model
cat(i, "\n")
}
forecasts <- Reduce(
f = cbind,
x = lapply(model_list, function(x) head(x$forecast, b))
) %>% as.matrix()
for (i in for_ind) {
filename <- paste0("forecast ",model_name,"-horizon-" , i, ".png")
filepath <- file.path("Plots", filename)
png(filepath, width = 1000, height = 600)
col_idx <- match(i, for_ind)  # find which column corresponds to horizon i
plot.ts(y_out,
main = paste0("Forecast with ", model_name, " (horizon = ", i, ")"),
lwd = 2)
lines(forecasts[, col_idx], col = 2, lwd = 2)
dev.off()
}
rmse <- apply(forecasts, 2, f_rmse, y = y_out) %>% print()
mae = apply(forecasts, 2, f_mae, y = y_out) %>% print()
results = list(mae = mae, rmse = rmse, forecasts = forecasts)
return(results)
}
mean_model <- call_models(datasetm, 'Mean', get_mean, "ibc_rs")
# h=1 RMSE: 0.1026092; MAE: 0.06800124
# h=3 RMSE: 0.1166696; MAE: 0.08106962
# h=6 RMSE: 0.1209282; MAE: 0.08549032
# h=12 RMSE: 0.1220261; MAE: 0.08669113
mean_model <- call_models(datasetw, 'Mean', get_mean, "ibc_rs")
# h=1 RMSE: 0.07011117; MAE: 0.04844195
# h=4 RMSE: 0.12220252 ; MAE: 0.10155142
benchmark <- call_models(datasetm, 'SARIMA', get_sarima, "ibc_rs")
mean_model <- call_models(datasetm, 'Mean - IBC-m', get_mean, "ibc_rs")
# h=1 RMSE: 0.1026092; MAE: 0.06800124
# h=3 RMSE: 0.1166696; MAE: 0.08106962
# h=6 RMSE: 0.1209282; MAE: 0.08549032
# h=12 RMSE: 0.1220261; MAE: 0.08669113
mean_model <- call_models(datasetw, 'Mean - IBC-w', get_mean, "ibc_rs")
# h=1 RMSE: 0.1026092  ; MAE:  0.06800124
# h=3 RMSE: 0.1166696  ; MAE:  0.08106962
# h=6 RMSE: 0.1209282  ; MAE:  0.08549032
# h=12 RMSE: 0.1220261 ; MAE:  0.08669113
rolling_window2 <- function(fn, df, nwindow = 1, horizon, variable, ...) {
#' Janela Movel para Modelagem
#'
#' Esta função aplica uma função especificada a uma janela deslizante de dados em um `data.frame` para realizar previsões.
#'
#' @param fn A função a ser aplicada em cada janela deslizante. Esta função deve retornar um objeto com as previsões e saídas.
#' @param df Um `data.frame` contendo os dados a serem processados.
#' @param nwindow O tamanho da janela deslizante. O padrão é 1.
#' @param horizon O horizonte de previsão, que determina quantas observações devem ser projetadas para frente.
#' @param variable O nome da variável dependente a ser utilizada na análise.
#' @param ... Argumentos adicionais a serem passados para a função `fn`.
#' @return Uma lista com dois elementos:
#' - forecast: Um vetor com as previsões resultantes de cada aplicação da função nas janelas deslizantes.
#' - outputs: Uma lista contendo as saídas resultantes de cada aplicação da função nas janelas deslizantes.
#'
#' @examples
#' df <- data.frame(data = 1:100, variable = rnorm(100))
#' result <- rolling_window(fn = my_forecast_function, df = df, nwindow = 5, horizon = 1, variable = 'variable')
#'
#' @export
n <- nrow(df)
w <- nwindow            # w == n - b + 1
h <- horizon
s <- w - h
b <- n - w + 1
# index matrix must be (s x b) and iterates through each column
indmat <- matrix(NA, s, b)
indmat[1, ] <- seq_len(b) # (first row is filled with numbers from 1 to b)
for (r in 2:nrow(indmat)) indmat[r, ] <- indmat[r - 1, ] + 1 # from row 2:s, row before +1
rw <- apply(
X = indmat,
MARGIN = 2, # iterates through columns.
FUN = fn,
df = df,
horizon = horizon,
variable = variable,
...
)
# print(rw)
# View(rw)
forecast <- unlist(lapply(rw, function(x) x$forecast))
outputs <- lapply(rw, function(x) x$outputs)
return(list(forecast = forecast, outputs = outputs))
}
benchmark <- call_models(datasetm, 'SARIMA - IBC-m', get_sarima, "ibc_rs")
# h=1 RMSE: 0.06805483 ; MAE:
# h=3 RMSE: 0.11789814 ; MAE:
# h=6 RMSE: 0.11679569 ; MAE:
# h=12 RMSE: 0.11412244 ; MAE:
benchmark <- call_models(datasetw, 'SARIMA - IBC-w', get_sarima, "ibc_rs")
# h=1 RMSE: ; MAE:
# h=3 RMSE: ; MAE:
# h=6 RMSE: ; MAE:
# h=12 RMSE: ; MAE:
# h=1 RMSE: 0.05920526  ; MAE: 0.04084625
# h=4 RMSE: 0.05988952  ; MAE: 0.04352576
lasso_model <- call_models(datasetm, 'LASSO - IBC-m', get_lasso, "ibc_rs")
# h=1 RMSE: 0.04012251 ; MAE:  0.03249728
# h=3 RMSE: 0.05493627 ; MAE:  0.03931377
# h=6 RMSE: 0.07379232 ; MAE:  0.05730493
# h=12 RMSE: 0.06383114 ; MAE: 0.04716723
lasso_model <- call_models(datasetw, 'LASSO - IBC-w', get_lasso, "ibc_rs")
call_models = function(data, model_name, model_function, variable, type = "default"){
#' Chamadas para Modelos de Previsão
#'
#' Esta função aplica um modelo de previsão a um conjunto de dados, utilizando uma janela deslizante para gerar previsões.
#'
#' @param data Um `data.frame` ou matriz contendo os dados a serem modelados.
#' @param model_name O nome do modelo a ser utilizado (apenas um rótulo).
#' @param model_function A função que implementa o modelo de previsão a ser aplicado.
#' @param variable O nome da variável dependente que será prevista.
#' @param type O tipo de dados. O padrão é "default".
#' @return Uma lista contendo os seguintes elementos:
#' - mae: O erro absoluto médio das previsões.
#' - rmse: A raiz do erro quadrático médio das previsões.
#' - forecasts: As previsões geradas pelo modelo para o horizonte definido.
#'
#' @examples
#' df <- data.frame(time = 1:100, variable = rnorm(100))
#' results <- call_models(data = df, model_name = "MyModel", model_function = my_model_function, variable = "variable")
#'
#' @export
data = as.matrix(data)
model_name <- model_name
model_function <- model_function
n <- nrow(data)
b = round(n*0.3) # base
y_out <- tail(data[, variable], b)
model_list <- list()
for_ind <- c(1, 4)
for (i in for_ind) {
model <- rolling_window2(
fn = model_function,
df = data,
nwindow = n - b + 1,
horizon = i,
variable = variable,
n_lags = 4
)
model_list[[i]] <- model
cat(i, "\n")
}
forecasts <- Reduce(
f = cbind,
x = lapply(model_list, function(x) head(x$forecast, b))
) %>% as.matrix()
for (i in for_ind) {
filename <- paste0("forecast ",model_name,"-horizon-" , i, ".png")
filepath <- file.path("Plots", filename)
png(filepath, width = 1000, height = 600)
col_idx <- match(i, for_ind)  # find which column corresponds to horizon i
plot.ts(y_out,
main = paste0("Forecast with ", model_name, " (horizon = ", i, ")"),
lwd = 2)
lines(forecasts[, col_idx], col = 2, lwd = 2)
dev.off()
}
rmse <- apply(forecasts, 2, f_rmse, y = y_out) %>% print()
mae = apply(forecasts, 2, f_mae, y = y_out) %>% print()
results = list(mae = mae, rmse = rmse, forecasts = forecasts)
return(results)
}
mean_model <- call_models(dataset, 'Mean - PIB_RS', get_mean, "pib_rs")
benchmark <- call_models(dataset, 'SARIMA - PIB_RS', get_sarima, "pib_rs")
lasso_model <- call_models(dataset, 'LASSO - PIB_RS', get_lasso, "pib_rs")
type_dfm
View(type_dfm)
View(CSFE)
get_sarima = function(ind, df, variable, horizon, n_lags){
#' Ajuste de Modelo SARIMA
#'
#' Esta função ajusta um modelo SARIMA aos dados fornecidos e gera previsões.
#'
#' @param ind Índices das observações a serem utilizadas.
#' @param df Um data.frame contendo os dados.
#' @param variable Nome da variável dependente a ser modelada.
#' @param horizon Horizonte de previsão.
#' @param n_lags Número de defasagens a serem usadas na modelagem.
#' @return Uma lista contendo as previsões do modelo SARIMA.
#'
#' @examples
#' results <- get_sarima(ind = 1:100, df = my_data, variable = "sales", horizon = 10, n_lags = 4)
library(tidyverse)
library(forecast)
data_in = dataprep(
ind = ind,
df = df,
variable = variable,
horizon = horizon,
n_lags = n_lags)
#INICIANDO AS VARIAVEIS
y_in = data_in$y_in
as.ts(y_in, frequency = 4)
reg_arima = auto.arima(
y = y_in,
stepwise = F,
approximation = F,
stationary = F,
seasonal = T,
start.p = 0,
start.q = 0)
print(reg_arima)
for_arima_aux = forecast(
object = reg_arima,
h = horizon)
forecasts = for_arima_aux$mean
results = list(forecasts = forecasts)
return (results)
}
call_models = function(data, model_name, model_function, variable, type = "default"){
#' Chamadas para Modelos de Previsão
#'
#' Esta função aplica um modelo de previsão a um conjunto de dados, utilizando uma janela deslizante para gerar previsões.
#'
#' @param data Um `data.frame` ou matriz contendo os dados a serem modelados.
#' @param model_name O nome do modelo a ser utilizado (apenas um rótulo).
#' @param model_function A função que implementa o modelo de previsão a ser aplicado.
#' @param variable O nome da variável dependente que será prevista.
#' @param type O tipo de dados. O padrão é "default".
#' @return Uma lista contendo os seguintes elementos:
#' - mae: O erro absoluto médio das previsões.
#' - rmse: A raiz do erro quadrático médio das previsões.
#' - forecasts: As previsões geradas pelo modelo para o horizonte definido.
#'
#' @examples
#' df <- data.frame(time = 1:100, variable = rnorm(100))
#' results <- call_models(data = df, model_name = "MyModel", model_function = my_model_function, variable = "variable")
#'
#' @export
data = as.matrix(data)
model_name <- model_name
model_function <- model_function
n <- nrow(data)
b = round(n*0.3) # base
y_out <- tail(data[, variable], b)
model_list <- list()
for_ind <- c(1, 3, 6, 12)
for (i in for_ind) {
model <- rolling_window2(
fn = model_function,
df = data,
nwindow = n - b + 1,
horizon = i,
variable = variable,
n_lags = 4
)
model_list[[i]] <- model
cat(i, "\n")
}
forecasts <- Reduce(
f = cbind,
x = lapply(model_list, function(x) head(x$forecast, b))
) %>% as.matrix()
for (i in for_ind) {
filename <- paste0("forecast ",model_name,"-horizon-" , i, ".png")
filepath <- file.path("Plots", filename)
png(filepath, width = 1000, height = 600)
col_idx <- match(i, for_ind)  # find which column corresponds to horizon i
plot.ts(y_out,
main = paste0("Forecast with ", model_name, " (horizon = ", i, ")"),
lwd = 2)
lines(forecasts[, col_idx], col = 2, lwd = 2)
dev.off()
}
rmse <- apply(forecasts, 2, f_rmse, y = y_out) %>% print()
mae = apply(forecasts, 2, f_mae, y = y_out) %>% print()
results = list(mae = mae, rmse = rmse, forecasts = forecasts)
return(results)
}
# h=1 RMSE: 0.07011117; MAE: 0.04844195
# h=4 RMSE: 0.12220252 ; MAE: 0.10155142
benchmark <- call_models(datasetm, 'SARIMA - IBC-m', get_sarima, "ibc_rs")
View(datasetm)
source("08_Compute_DM.R")
source("09_Performance_csfe.R")
View(compute_dm)
# h=1 RMSE: 0.05920526  ; MAE: 0.04084625
# h=4 RMSE: 0.05988952  ; MAE: 0.04352576
lasso_mmodel <- call_models(datasetm, 'LASSO - IBC-m', get_lasso, "ibc_rs")
# h=1 RMSE: 0.04012251 ; MAE:  0.03249728
# h=3 RMSE: 0.05493627 ; MAE:  0.03931377
# h=6 RMSE: 0.07379232 ; MAE:  0.05730493
# h=12 RMSE: 0.06383114 ; MAE: 0.04716723
lasso_wmodel <- call_models(datasetw, 'LASSO - IBC-w', get_lasso, "ibc_rs")
compute_dm = function(){
#' Computa o Teste de Diebold-Mariano para Modelos de Previsão
#'
#' Esta função calcula o teste de Diebold-Mariano para diferentes modelos de previsão e horizontes de previsão.
#'
#' @return Uma lista contendo matrizes de valores-p formatadas com estrelas para três conjuntos de modelos:
#'   - pvalues_tb: valores-p para modelos baseados em texto.
#'   - pvalues_eco: valores-p para modelos econômicos.
#'   - pvalues_eco_tb: valores-p para modelos que combinam dados econômicos e baseados em texto.
#'
#' @examples
#' dm_results <- compute_dm()
model_names <- c("LASSO", "Elastic Net", "Random Forest", "Boosting")
horizons <- c(1, 3, 6, 12)
##################################################
############## DM FOR TEXT BASE ##################
##################################################
model_dataframes <- list(lasso_mmodel, lasso_wmodel)
pvalues <- matrix(nrow = length(model_names), ncol = length(horizons))
results <- list()
results_tb = results
pvalues_tb = pvalues
for (m in seq_along(model_names)) {
model_name <- model_names[m]
model_df <- model_dataframes[[m]]
for (i in seq_along(horizons)) {
h <- horizons[i]
x <- data.frame(benchmark$forecasts)[[i]]
y <- data.frame(model_df$forecasts)[[i]]
#residual = y - ŷ
dm = dm.test(
e1 = datasetm$`ibc_rs`[181:257] - y,
e2 = datasetm$`ibc_rs`[181:257] - x,
h = h,
alternative = 'two.sided',
varestimator = 'bartlett'
)
pvalues[m, i] <- dm$p.value
results[[paste0(model_name, '- horizon ', h)]] <- dm
}
}
rownames(pvalues) <- model_names
colnames(pvalues) <- horizons
pvalues_eco_stars <- add_stars(pvalues)
pvalues <- matrix(paste0(format(pvalues, nsmall = 10), pvalues_eco_stars), nrow = nrow(pvalues), dimnames = dimnames(pvalues))
pvalues
list = list(
pvalues = pvalues)
return(list)
}
csfe = function(model, benchmark, y_real){
#' Calcula CSFE para Diferentes Horizontes
#'
#' Esta função calcula o Cumulative Squared Forecast Error (CSFE) para diferentes horizontes de previsão
#' a partir das previsões de um modelo e de um benchmark.
#'
#' @param model Um objeto contendo as previsões do modelo, com colunas representando diferentes horizontes.
#' @param benchmark Um objeto contendo as previsões do benchmark, com colunas correspondendo aos mesmos horizontes.
#' @param y_real Um vetor numérico contendo os valores reais observados.
#' @return Uma matriz com os erros quadráticos acumulados para cada horizonte de previsão.
#'
#' @examples
#' csfe_results <- csfe(model, benchmark, y_real)
#' print(csfe_results)
#'
h1 = f_csfe(model$forecast[,1], benchmark$forecasts[,1], y_real = y_real)
h3 = f_csfe(model$forecast[,2], benchmark$forecasts[,2], y_real = y_real)
h6 = f_csfe(model$forecast[,3], benchmark$forecasts[,3], y_real = y_real)
h12 = f_csfe(model$forecast[,4], benchmark$forecasts[,4], y_real = y_real)
cbind(h1, h3, h6, h12)
}
csfem_lasso = csfe(lasso_model, benchmark, datasetm$"ibc_rs"[181:257])
View(lasso_mmodel)
lasso_mmodel[["forecasts"]]
csfem_lasso = csfe(lasso_model, benchmark, datasetm$"ibc_rs"[180:257])
csfem_lassom = csfe(lasso_mmodel, benchmarkm, datasetm$"ibc_rs"[181:257])
# h=1 RMSE: 0.07011117; MAE: 0.04844195
# h=4 RMSE: 0.12220252 ; MAE: 0.10155142
benchmarkm <- call_models(datasetm, 'SARIMA - IBC-m', get_sarima, "ibc_rs")
csfem_lassom = csfe(lasso_mmodel, benchmarkm, datasetm$"ibc_rs"[181:257])
csfem_lassow = csfe(lasso_wmodel, benchmarkm, datasetm$"ibc_rs"[181:257])
# Base R plotting
plot(date[181:257], csfem_lassom$h1, type = "l", col = "orange", lwd = 2, ylim = c(-0.01, 0.056),
ylab = "h1", xlab = "Index", main = "Comparison of h1 across models")
csfem_lassom <- as.data.frame(csfe_lasso)
csfem_lassom <- as.data.frame(csfem_lassom)
csfem_lassow <- as.data.frame(csfem_lassow)
# Base R plotting
plot(date[181:257], csfem_lassom$h1, type = "l", col = "orange", lwd = 2, ylim = c(-0.01, 0.056),
ylab = "h1", xlab = "Index", main = "Comparison of h1 across models")
csfem_lassom = csfe(lasso_mmodel, benchmarkm, datasetm$"ibc_rs"[181:257])
csfem_lassom <- as.data.frame(csfem_lassom)
# Base R plotting
plot(date[181:257], csfem_lassom$h1, type = "l", col = "orange", lwd = 2, ylim = c(-0.01, 0.056),
ylab = "h1", xlab = "Index", main = "Comparison of h1 across models")
# Base R plotting
plot(dfdate[181:257], csfem_lasso$h3, type = "l", col = "orange", lwd = 2, ylim = c(0.05, 0.04),
ylab = "h3", xlab = "Index", main = "Comparison of h4 across models")
# Base R plotting
plot(dfdate[181:257], csfem_lassom$h1, type = "l", col = "orange", lwd = 2, ylim = c(-0.01, 0.056),
ylab = "h1", xlab = "Index", main = "Comparison of h1 across models")
lines(date[181:257], csfem_lassow$h1, col = "red",   lwd = 2)
