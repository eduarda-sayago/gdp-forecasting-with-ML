) %>% as.matrix()
for (i in for_ind) {
filename <- paste0("forecast ",model_name,"-horizon-" , i, ".png")
filepath <- file.path("Plots", filename)
png(filepath, width = 1000, height = 600)
col_idx <- match(i, for_ind)  # find which column corresponds to horizon i
plot.ts(y_out,
main = paste0("Forecast with ", model_name, " (horizon = ", i, ")"),
lwd = 2)
lines(forecasts[, col_idx], col = 2, lwd = 2)
dev.off()
}
rmse <- apply(forecasts, 2, f_rmse, y = y_out) %>% print()
mae = apply(forecasts, 2, f_mae, y = y_out) %>% print()
results = list(mae = mae, rmse = rmse, forecasts = forecasts)
return(results)
}
mean_model <- call_models(dataset, 'Mean - PIB_RS', get_mean, "pib_rs")
benchmark <- call_models(dataset, 'SARIMA - PIB_RS', get_sarima, "pib_rs")
lasso_model <- call_models(dataset, 'LASSO - PIB_RS', get_lasso, "pib_rs")
type_dfm
View(type_dfm)
View(CSFE)
get_sarima = function(ind, df, variable, horizon, n_lags){
#' Ajuste de Modelo SARIMA
#'
#' Esta função ajusta um modelo SARIMA aos dados fornecidos e gera previsões.
#'
#' @param ind Índices das observações a serem utilizadas.
#' @param df Um data.frame contendo os dados.
#' @param variable Nome da variável dependente a ser modelada.
#' @param horizon Horizonte de previsão.
#' @param n_lags Número de defasagens a serem usadas na modelagem.
#' @return Uma lista contendo as previsões do modelo SARIMA.
#'
#' @examples
#' results <- get_sarima(ind = 1:100, df = my_data, variable = "sales", horizon = 10, n_lags = 4)
library(tidyverse)
library(forecast)
data_in = dataprep(
ind = ind,
df = df,
variable = variable,
horizon = horizon,
n_lags = n_lags)
#INICIANDO AS VARIAVEIS
y_in = data_in$y_in
as.ts(y_in, frequency = 4)
reg_arima = auto.arima(
y = y_in,
stepwise = F,
approximation = F,
stationary = F,
seasonal = T,
start.p = 0,
start.q = 0)
print(reg_arima)
for_arima_aux = forecast(
object = reg_arima,
h = horizon)
forecasts = for_arima_aux$mean
results = list(forecasts = forecasts)
return (results)
}
call_models = function(data, model_name, model_function, variable, type = "default"){
#' Chamadas para Modelos de Previsão
#'
#' Esta função aplica um modelo de previsão a um conjunto de dados, utilizando uma janela deslizante para gerar previsões.
#'
#' @param data Um `data.frame` ou matriz contendo os dados a serem modelados.
#' @param model_name O nome do modelo a ser utilizado (apenas um rótulo).
#' @param model_function A função que implementa o modelo de previsão a ser aplicado.
#' @param variable O nome da variável dependente que será prevista.
#' @param type O tipo de dados. O padrão é "default".
#' @return Uma lista contendo os seguintes elementos:
#' - mae: O erro absoluto médio das previsões.
#' - rmse: A raiz do erro quadrático médio das previsões.
#' - forecasts: As previsões geradas pelo modelo para o horizonte definido.
#'
#' @examples
#' df <- data.frame(time = 1:100, variable = rnorm(100))
#' results <- call_models(data = df, model_name = "MyModel", model_function = my_model_function, variable = "variable")
#'
#' @export
data = as.matrix(data)
model_name <- model_name
model_function <- model_function
n <- nrow(data)
b = round(n*0.3) # base
y_out <- tail(data[, variable], b)
model_list <- list()
for_ind <- c(1, 3, 6, 12)
for (i in for_ind) {
model <- rolling_window2(
fn = model_function,
df = data,
nwindow = n - b + 1,
horizon = i,
variable = variable,
n_lags = 4
)
model_list[[i]] <- model
cat(i, "\n")
}
forecasts <- Reduce(
f = cbind,
x = lapply(model_list, function(x) head(x$forecast, b))
) %>% as.matrix()
for (i in for_ind) {
filename <- paste0("forecast ",model_name,"-horizon-" , i, ".png")
filepath <- file.path("Plots", filename)
png(filepath, width = 1000, height = 600)
col_idx <- match(i, for_ind)  # find which column corresponds to horizon i
plot.ts(y_out,
main = paste0("Forecast with ", model_name, " (horizon = ", i, ")"),
lwd = 2)
lines(forecasts[, col_idx], col = 2, lwd = 2)
dev.off()
}
rmse <- apply(forecasts, 2, f_rmse, y = y_out) %>% print()
mae = apply(forecasts, 2, f_mae, y = y_out) %>% print()
results = list(mae = mae, rmse = rmse, forecasts = forecasts)
return(results)
}
# h=1 RMSE: 0.07011117; MAE: 0.04844195
# h=4 RMSE: 0.12220252 ; MAE: 0.10155142
benchmark <- call_models(datasetm, 'SARIMA - IBC-m', get_sarima, "ibc_rs")
View(datasetm)
source("08_Compute_DM.R")
source("09_Performance_csfe.R")
View(compute_dm)
# h=1 RMSE: 0.05920526  ; MAE: 0.04084625
# h=4 RMSE: 0.05988952  ; MAE: 0.04352576
lasso_mmodel <- call_models(datasetm, 'LASSO - IBC-m', get_lasso, "ibc_rs")
# h=1 RMSE: 0.04012251 ; MAE:  0.03249728
# h=3 RMSE: 0.05493627 ; MAE:  0.03931377
# h=6 RMSE: 0.07379232 ; MAE:  0.05730493
# h=12 RMSE: 0.06383114 ; MAE: 0.04716723
lasso_wmodel <- call_models(datasetw, 'LASSO - IBC-w', get_lasso, "ibc_rs")
compute_dm = function(){
#' Computa o Teste de Diebold-Mariano para Modelos de Previsão
#'
#' Esta função calcula o teste de Diebold-Mariano para diferentes modelos de previsão e horizontes de previsão.
#'
#' @return Uma lista contendo matrizes de valores-p formatadas com estrelas para três conjuntos de modelos:
#'   - pvalues_tb: valores-p para modelos baseados em texto.
#'   - pvalues_eco: valores-p para modelos econômicos.
#'   - pvalues_eco_tb: valores-p para modelos que combinam dados econômicos e baseados em texto.
#'
#' @examples
#' dm_results <- compute_dm()
model_names <- c("LASSO", "Elastic Net", "Random Forest", "Boosting")
horizons <- c(1, 3, 6, 12)
##################################################
############## DM FOR TEXT BASE ##################
##################################################
model_dataframes <- list(lasso_mmodel, lasso_wmodel)
pvalues <- matrix(nrow = length(model_names), ncol = length(horizons))
results <- list()
results_tb = results
pvalues_tb = pvalues
for (m in seq_along(model_names)) {
model_name <- model_names[m]
model_df <- model_dataframes[[m]]
for (i in seq_along(horizons)) {
h <- horizons[i]
x <- data.frame(benchmark$forecasts)[[i]]
y <- data.frame(model_df$forecasts)[[i]]
#residual = y - ŷ
dm = dm.test(
e1 = datasetm$`ibc_rs`[181:257] - y,
e2 = datasetm$`ibc_rs`[181:257] - x,
h = h,
alternative = 'two.sided',
varestimator = 'bartlett'
)
pvalues[m, i] <- dm$p.value
results[[paste0(model_name, '- horizon ', h)]] <- dm
}
}
rownames(pvalues) <- model_names
colnames(pvalues) <- horizons
pvalues_eco_stars <- add_stars(pvalues)
pvalues <- matrix(paste0(format(pvalues, nsmall = 10), pvalues_eco_stars), nrow = nrow(pvalues), dimnames = dimnames(pvalues))
pvalues
list = list(
pvalues = pvalues)
return(list)
}
csfe = function(model, benchmark, y_real){
#' Calcula CSFE para Diferentes Horizontes
#'
#' Esta função calcula o Cumulative Squared Forecast Error (CSFE) para diferentes horizontes de previsão
#' a partir das previsões de um modelo e de um benchmark.
#'
#' @param model Um objeto contendo as previsões do modelo, com colunas representando diferentes horizontes.
#' @param benchmark Um objeto contendo as previsões do benchmark, com colunas correspondendo aos mesmos horizontes.
#' @param y_real Um vetor numérico contendo os valores reais observados.
#' @return Uma matriz com os erros quadráticos acumulados para cada horizonte de previsão.
#'
#' @examples
#' csfe_results <- csfe(model, benchmark, y_real)
#' print(csfe_results)
#'
h1 = f_csfe(model$forecast[,1], benchmark$forecasts[,1], y_real = y_real)
h3 = f_csfe(model$forecast[,2], benchmark$forecasts[,2], y_real = y_real)
h6 = f_csfe(model$forecast[,3], benchmark$forecasts[,3], y_real = y_real)
h12 = f_csfe(model$forecast[,4], benchmark$forecasts[,4], y_real = y_real)
cbind(h1, h3, h6, h12)
}
csfem_lasso = csfe(lasso_model, benchmark, datasetm$"ibc_rs"[181:257])
View(lasso_mmodel)
lasso_mmodel[["forecasts"]]
csfem_lasso = csfe(lasso_model, benchmark, datasetm$"ibc_rs"[180:257])
csfem_lassom = csfe(lasso_mmodel, benchmarkm, datasetm$"ibc_rs"[181:257])
# h=1 RMSE: 0.07011117; MAE: 0.04844195
# h=4 RMSE: 0.12220252 ; MAE: 0.10155142
benchmarkm <- call_models(datasetm, 'SARIMA - IBC-m', get_sarima, "ibc_rs")
csfem_lassom = csfe(lasso_mmodel, benchmarkm, datasetm$"ibc_rs"[181:257])
csfem_lassow = csfe(lasso_wmodel, benchmarkm, datasetm$"ibc_rs"[181:257])
# Base R plotting
plot(date[181:257], csfem_lassom$h1, type = "l", col = "orange", lwd = 2, ylim = c(-0.01, 0.056),
ylab = "h1", xlab = "Index", main = "Comparison of h1 across models")
csfem_lassom <- as.data.frame(csfe_lasso)
csfem_lassom <- as.data.frame(csfem_lassom)
csfem_lassow <- as.data.frame(csfem_lassow)
# Base R plotting
plot(date[181:257], csfem_lassom$h1, type = "l", col = "orange", lwd = 2, ylim = c(-0.01, 0.056),
ylab = "h1", xlab = "Index", main = "Comparison of h1 across models")
csfem_lassom = csfe(lasso_mmodel, benchmarkm, datasetm$"ibc_rs"[181:257])
csfem_lassom <- as.data.frame(csfem_lassom)
# Base R plotting
plot(date[181:257], csfem_lassom$h1, type = "l", col = "orange", lwd = 2, ylim = c(-0.01, 0.056),
ylab = "h1", xlab = "Index", main = "Comparison of h1 across models")
# Base R plotting
plot(dfdate[181:257], csfem_lasso$h3, type = "l", col = "orange", lwd = 2, ylim = c(0.05, 0.04),
ylab = "h3", xlab = "Index", main = "Comparison of h4 across models")
# Base R plotting
plot(dfdate[181:257], csfem_lassom$h1, type = "l", col = "orange", lwd = 2, ylim = c(-0.01, 0.056),
ylab = "h1", xlab = "Index", main = "Comparison of h1 across models")
lines(date[181:257], csfem_lassow$h1, col = "red",   lwd = 2)
View(csfe_enet)
# ================================================
# --------------------Graphs----------------------
# ================================================
y_axis <- dfdate[181:257]
CSFE_df <- data.frame(date = y_axis,
lasso_h1 = csfem_lasso$h1,
lasso_h12 = csfem_lasso$h12,
enet_h1 = csfem_enet$h1,
enet_h12 = csfem_enet$h12,
rf_h1 = csfem_rf$h1,
rf_h12 = csfem_rf$h12)
yi <- datasetm$`ibc_rs`[181:257]
dm_tests_ibc <- compute_dm1(model_names = c("LASSO", "Elastic Net", "Random Forest"),
model_dataframes = list(lasso_model, enet_model, rf_model),
horizons = c(1, 12),
orig_data = yi)
source("01_get_Data.R")
source("02_get_Log_Transformations.R")
source("03_get_Stationarity.R")
source("04_get_Data_Prep.R")
source("05_get_Rolling_Window.R")
source("06_get_Models.R")
source("07_call_Model.R")
source("08_Compute_DM.R")
source("09_Performance_csfe.R")
yi <- datasetm$`ibc_rs`[181:257]
dm_tests_ibc <- compute_dm1(model_names = c("LASSO", "Elastic Net", "Random Forest"),
model_dataframes = list(lasso_model, enet_model, rf_model),
horizons = c(1, 12),
orig_data = yi)
source("01_get_Data.R")
source("02_get_Log_Transformations.R")
source("03_get_Stationarity.R")
source("04_get_Data_Prep.R")
source("05_get_Rolling_Window.R")
source("06_get_Models.R")
source("07_call_Model.R")
source("08_Compute_DM.R")
source("09_Performance_csfe.R")
c
add_stars <- function(pvalues, alpha_levels = c(0.05, 0.01, 0.001)) {
#' Adiciona Estrelas para Indicar Níveis de Significância
#'
#' Esta função atribui estrelas (*) aos valores-p com base em níveis de significância especificados.
#'
#' @param pvalues Um vetor de valores-p.
#' @param alpha_levels Um vetor de níveis de significância (padrão: 0.05, 0.01, 0.001).
#'
#' @return Um vetor de caracteres com estrelas correspondentes aos valores-p.
#'
#' @examples
#' stars <- add_stars(c(0.02, 0.001, 0.07))
#'
stars <- character(length(pvalues))
for (i in seq_along(alpha_levels)) {
stars[pvalues <= alpha_levels[i]] <- paste(rep("*", i), collapse = "")
}
return(stars)
}
View(dm_tests)
dm_tests[["pvalues"]]
datasetw <- get_seas_stationarity(logw_results, type_df = type_dfw, freq = 12)
benchmark <- call_models1(datasetm, 'SARIMA - IBC-m', get_sarima, "ibc_rs")
#rm(raww_ibc_log, logw_results, raww_stry)
rm(bench_newRW, benchmark1, benchmark2, benchmarkm, boosting_model, csfem_lassom)
#rm(raww_ibc_log, logw_results, raww_stry)
rm(csfem_lassow, dataframe, datasetw,df,dummies, elasticnet_coefs_history,enet_NWmodel,exp_res,f, fit, lasso_coefs_history,lasso_EW,lasso_mmodel,lasso_newRW,lasso_NWmodel,lasso_wmodel,m1,m2,meandm_test,previ,raww_ibc,raww_list,rf_NWmodel,roll_res,roll_res2,sarima_model,single_res,type_dfw)
enet_model <- call_models1(datasetm, 'Elastic Net - IBC-m', get_elasticnet, "ibc_rs")
#csfep_boosting <- as.data.frame(csfep_boosting)
rm(CSFE)
View(datasetm)
datasetm$date <- as.Date(datasetm$date, origin = "1970-01-01")
datasetm$date <- as.Date(datasetm$date, origin = "1970-01-01")
View(datasetm)
rawm_ibc <- readRDS("rawM_ibc.rds")
# raww_ibc <- readRDS("rawW_ibc.rds")
# ================================================
# --------Preprocessing for Stationarity----------
# ================================================
message("[2] Applying log transforms")
rawm_ibc_log <- get_logs(rawm_ibc)
type_dfm <- rawm_ibc_log$type_df
logm_results <- do.call(cbind, rawm_ibc_log$results) %>% as.data.frame()
# santavpalmar insolacaototal - possibly contains mistakes in data
# raww_ibc_log <- get_logs(raww_ibc)
# type_dfw <- raww_ibc_log$type_df
# logw_results <- do.call(cbind, raww_ibc_log$results) %>% as.data.frame()
# ================================================
# --------------Stationarity tests----------------
# ================================================
message("[3] Applying ADF test and differencing")
rawm_stry <- get_stationarity(logm_results, type_df = type_dfm)
#raww_stry <- get_stationarity(logw_results, type_df = type_dfw)
type_dfm <- rawm_stry$type_df
rawm_stry <- as.data.frame(rawm_stry$df)
# type_dfw <- raww_stry$type_df
# raww_stry <- as.data.frame(raww_stry$df)
message("[4] Applying seasonal differencing")
datasetm <- get_seas_stationarity(logm_results, type_df = type_dfm, freq = 12)
#datasetw <- get_seas_stationarity(logw_results, type_df = type_dfw, freq = 12)
type_dfm <- datasetm$type_df
datasetm <- as.data.frame(datasetm$df)
datasetm$date <- as.Date(datasetm$date, origin = "1970-01-01")
dummies <- data.frame(matrix(ncol = 0, nrow = nrow(datasetm)))
dummies$month <- lubridate::month(datasetm$date)
datasetm$M2 <- ifelse(dummies$month == 2, 1, 0)
datasetm$M3 <- ifelse(dummies$month == 3, 1, 0)
datasetm$M4 <- ifelse(dummies$month == 4, 1, 0)
datasetm$M5 <- ifelse(dummies$month == 5, 1, 0)
datasetm$M6 <- ifelse(dummies$month == 6, 1, 0)
datasetm$M7 <- ifelse(dummies$month == 7, 1, 0)
datasetm$M8 <- ifelse(dummies$month == 8, 1, 0)
datasetm$M9 <- ifelse(dummies$month == 9, 1, 0)
datasetm$M10 <- ifelse(dummies$month == 10, 1, 0)
datasetm$M11 <- ifelse(dummies$month == 11, 1, 0)
datasetm$M12 <- ifelse(dummies$month == 12, 1, 0)
datasetm$d_pandemic <- ifelse(datasetm$date >= as.Date("2020-01-01") &
datasetm$date <= as.Date("2020-10-01"), 1, 0)
#datasetm$d_rsflood <- ifelse(datasetm$date == as.Date("2024-06-01"), 1, 0)
datasetm$d_shift <- ifelse(datasetm$date < as.Date("2013-01-01"),
seq_len(sum(datasetm$date < as.Date("2013-01-01"))),0)
View(datasetm)
# Adding dummies in datasetw
# ...
saveRDS(datasetm,"datasetm.rds")
# Storing and removing Date column
dfdate = datasetm$date
dfdate = as.Date(date, origin = "1970-01-01")
datasetm$date <- NULL
datasetm[] <- lapply(datasetm, as.numeric)
rm(dummies, rawm_ibc_log, logm_results, rawm_stry)
View(lasso_model)
lasso_model <- call_models1(datasetm, 'LASSO - IBC-m', get_lasso, "ibc_rs")
enet_model <- call_models1(datasetm, 'Elastic Net - IBC-m', get_elasticnet, "ibc_rs")
rf_model <- call_models1(datasetm, 'Random Forest - IBC-m', get_rf, "ibc_rs")
get_logs2 <- function(df) {
# df: data.frame com as séries (cada coluna é uma variável)
# devolve: lista com $results (data.frame) e $type_df (data.frame: variable, tipo)
n <- ncol(df)
results <- df # inicialmente copia (vamos substituir só as colunas transformáveis)
types <- integer(n)
names(types) <- colnames(df)
for (i in seq_len(n)) {
x <- df[[i]]
colname <- colnames(df)[i]
# 4 = coluna de data (mantemos sem transformação)
if (inherits(x, "Date") || inherits(x, "POSIXt")) {
types[i] <- 4
results[[i]] <- x
next
}
has_neg <- any(x < 0, na.rm = TRUE)
has_zero <- any(x == 0, na.rm = TRUE)
# Mapping:
# type 0 = positive → log(X)
# type 1 = zeroes → log(X + 2)
# type 2 = negatives → nothing
# type 3 = zeroes and neg → X + 1
if (!has_neg && !has_zero) {
types[i] <- 0L
results[[i]] <- log(x)
} else if (!has_neg && has_zero) {
types[i] <- 1L
results[[i]] <- log(x + 2)
} else if (has_neg && !has_zero) {
types[i] <- 2L
results[[i]] <- log(x -min(x) +2)
} else { # has_neg && has_zero
types[i] <- 3L
results[[i]] <- log(x -min(x) +2)
}
}
type_df <- data.frame(
variable = colnames(df),
type = as.integer(types),
stringsAsFactors = FALSE
)
return(list(results = as.data.frame(results), type_df = type_df))
}
get_quarterly <- function(df) {
#' Aggregate Monthly Data to Quarterly (mean of months)
#'
#' @param df A data.frame with a Date column named "date" and monthly variables (numeric).
#' @return A data.frame aggregated to quarterly frequency. Only quarters with exactly 3
#'         monthly observations are retained. The returned date is the first day of the
#'         quarter's last month (Mar/Jun/Sep/Dec).
#' @details Only quarters with exactly 3 observations are kept.
# checks
if (!"date" %in% names(df)) stop("'date' column not found in df")
df$date <- as.Date(df$date)
if (!inherits(df$date, "Date")) stop("'date' column must be a Date or coercible to Date")
# identify numeric columns to aggregate (exclude the date column itself)
numeric_cols <- setdiff(names(df)[vapply(df, is.numeric, logical(1))], "date")
if (length(numeric_cols) == 0L) stop("no numeric columns found to aggregate")
# year, month, quarter id
y <- as.integer(format(df$date, "%Y"))
m <- as.integer(format(df$date, "%m"))
qnum <- (m - 1) %/% 3 + 1            # 1..4
qid <- paste0(y, "Q", qnum)
# keep only groups (quarters) with exactly 3 observations
q_counts <- table(qid)
valid_q <- names(q_counts[q_counts == 3])
if (length(valid_q) == 0L) {
# return empty df with expected structure
return(data.frame(date = as.Date(character(0)), matrix(ncol = length(numeric_cols), nrow = 0,
dimnames = list(NULL, numeric_cols))))
}
# restrict to valid rows
keep_idx <- qid %in% valid_q
df_valid <- df[keep_idx, , drop = FALSE]
qid_valid <- qid[keep_idx]
# split numeric data by quarter and compute means
splitted <- split(df_valid[, numeric_cols, drop = FALSE], qid_valid)
agg_list <- lapply(splitted, function(subdf) {
# each subdf should have 3 rows; compute column means (will return numeric vector)
v <- colMeans(subdf, na.rm = FALSE) # na.rm = FALSE so NA in any month -> NA for quarter (matches "exactly 3 obs" policy)
as.numeric(v)
})
agg_mat <- do.call(rbind, agg_list)           # rows = quarters (named by qid), cols = numeric_cols
colnames(agg_mat) <- numeric_cols
# determine the last date of each quarter and convert it to first day of that month
last_dates <- tapply(df_valid$date, qid_valid, max)
# last_dates order matches rownames of agg_mat if split preserves order of names; ensure same ordering
q_names_ordered <- rownames(agg_mat)
last_dates <- as.Date(last_dates[q_names_ordered])
# build quarterly date as first day of last month of quarter
q_years <- as.integer(format(last_dates, "%Y"))
q_end_months <- as.integer(format(last_dates, "%m"))
quarter_date <- as.Date(sprintf("%04d-%02d-01", q_years, q_end_months))
# assemble final data.frame
out_df <- data.frame(date = quarter_date, agg_mat, row.names = NULL, stringsAsFactors = FALSE)
# ensure ordering by date
out_df <- out_df[order(out_df$date), , drop = FALSE]
rownames(out_df) <- NULL
return(out_df)
}
get_quarterly <- function(df) {
#' Aggregate Monthly Data to Quarterly (mean of months)
#' @param df A data.frame with a "date" column and numeric monthly variables.
#' @return A data.frame aggregated to quarterly frequency (full quarters only).
df$date <- as.Date(df$date)
numeric_cols <- setdiff(names(df), "date")
# Assign quarter IDs
y <- as.integer(format(df$date, "%Y"))
m <- as.integer(format(df$date, "%m"))
qid <- paste0(y, "Q", (m - 1) %/% 3 + 1)
# Keep only quarters with 3 observations
counts <- table(qid)
valid_q <- names(counts[counts == 3])
df <- df[qid %in% valid_q, ]
qid <- qid[qid %in% valid_q]
# Aggregate numeric columns by quarter
agg <- t(sapply(split(df[, numeric_cols, drop = FALSE], qid), colMeans))
# Determine first day of last month in each quarter
last_dates <- tapply(df$date, qid, max)
quarter_dates <- as.Date(sprintf("%04d-%02d-01", as.integer(format(last_dates, "%Y")),
as.integer(format(last_dates, "%m"))))
# Build final data.frame
out_df <- data.frame(date = quarter_dates, agg, row.names = NULL)
out_df[order(out_df$date), , drop = FALSE]
}
View(type_dfm)
dataset <- readRDS("dataset.rds")
View(dataset)
datasetn <- dataset[1:71,]
dataset$date <- NULL
dataset[] <- lapply(dataset, as.numeric)
daten <- dataset$date[1:71,]
datasetn$date <- NULL
datasetn[] <- lapply(datasetn, as.numeric)
